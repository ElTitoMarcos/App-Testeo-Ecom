"""
Database layer for the Product Research Copilot.

This module defines helper functions to manage a local SQLite database.  The database
stores imported products, scores generated by the AI model, user defined lists and
other ancillary data.  Using SQLite allows the entire application to run locally
without any additional infrastructure.  As the project grows the same API can be
adapted to other backends such as PostgreSQL by changing the connection string.

Tables:
    products      -- core table storing product metadata
    scores        -- table storing AIâ€‘generated scores and explanations
    lists         -- table storing user defined collection names
    list_items    -- junction table associating products to lists

All date/time fields are stored as ISO 8601 strings for simplicity.
"""

import json
import sqlite3
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


def get_connection(db_path: Path) -> sqlite3.Connection:
    """Return a SQLite connection to the specified database file.

    The database file will be created if it does not exist.  Foreign key support
    is enabled on every connection.

    Args:
        db_path: Path to the SQLite file.

    Returns:
        A sqlite3.Connection object.
    """
    conn = sqlite3.connect(str(db_path))
    conn.row_factory = sqlite3.Row
    # Enable pragmas for reliability and performance
    conn.execute("PRAGMA journal_mode=WAL")
    conn.execute("PRAGMA synchronous=NORMAL")
    conn.execute("PRAGMA foreign_keys=ON")
    return conn


def initialize_database(conn: sqlite3.Connection) -> None:
    """Create tables if they do not exist.

    This function can be run repeatedly; it will only create missing tables.

    Args:
        conn: A SQLite connection instance.
    """
    cur = conn.cursor()
    # Products table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            description TEXT,
            category TEXT,
            price REAL,
            currency TEXT,
            image_url TEXT,
            source TEXT,
            import_date TEXT NOT NULL,
            desire TEXT,
            desire_magnitude TEXT,
            awareness_level TEXT,
            competition_level TEXT,
            date_range TEXT,
            extra JSON
        )
        """
    )
    cur.execute("PRAGMA table_info(products)")
    cols = [row[1] for row in cur.fetchall()]
    if "desire" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN desire TEXT")
    if "desire_magnitude" not in cols and "magnitud_deseo" in cols:
        cur.execute("ALTER TABLE products RENAME COLUMN magnitud_deseo TO desire_magnitude")
    elif "desire_magnitude" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN desire_magnitude TEXT")
    if "awareness_level" not in cols and "nivel_consciencia" in cols:
        cur.execute("ALTER TABLE products RENAME COLUMN nivel_consciencia TO awareness_level")
    elif "awareness_level" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN awareness_level TEXT")
    if "competition_level" not in cols and "saturacion_mercado" in cols:
        cur.execute("ALTER TABLE products RENAME COLUMN saturacion_mercado TO competition_level")
    elif "competition_level" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN competition_level TEXT")
    if "date_range" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN date_range TEXT")
    if "ai_columns_completed_at" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN ai_columns_completed_at TEXT")
    metric_text_cols = [
        "magnitud_deseo",
        "nivel_consciencia_headroom",
        "competition_level_invertido",
        "facilidad_anuncio",
        "escalabilidad",
        "durabilidad_recurrencia",
    ]
    metric_real_cols = [
        "evidencia_demanda",
        "tasa_conversion",
        "ventas_por_dia",
        "recencia_lanzamiento",
    ]
    for col in metric_text_cols:
        if col not in cols:
            cur.execute(f"ALTER TABLE products ADD COLUMN {col} TEXT")
    for col in metric_real_cols:
        if col not in cols:
            cur.execute(f"ALTER TABLE products ADD COLUMN {col} REAL")
    # drop obsolete columns if present
    for obsolete in [
        "facilidad_logistica",
        "engagement_shareability",
    ]:
        if obsolete in cols:
            try:
                cur.execute(f"ALTER TABLE products DROP COLUMN {obsolete}")
            except Exception:
                pass
    # Scores table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS scores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            product_id INTEGER NOT NULL,
            model TEXT NOT NULL,
            total_score REAL,
            momentum REAL,
            saturation REAL,
            differentiation REAL,
            social_proof REAL,
            margin REAL,
            logistics REAL,
            summary TEXT,
            explanations JSON,
            created_at TEXT NOT NULL,
            winner_score_raw REAL,
            winner_score INTEGER,
            winner_score_breakdown JSON,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    cur.execute("PRAGMA table_info(scores)")
    info = cur.fetchall()
    cols = [row[1] for row in info]
    types = {row[1]: row[2].upper() for row in info}
    if "winner_score_raw" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score_raw REAL")
    if "winner_score" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score INTEGER")
    elif types.get("winner_score") != "INTEGER":
        cur.execute("ALTER TABLE scores RENAME TO scores_old")
        cur.execute(
            """
            CREATE TABLE scores (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                product_id INTEGER NOT NULL,
                model TEXT NOT NULL,
                total_score REAL,
                momentum REAL,
                saturation REAL,
                differentiation REAL,
                social_proof REAL,
                margin REAL,
                logistics REAL,
                summary TEXT,
                explanations JSON,
                created_at TEXT NOT NULL,
                winner_score_raw REAL,
                winner_score INTEGER,
                winner_score_breakdown JSON,
                FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
            )
            """
        )
        cur.execute(
            """
            INSERT INTO scores (
                id, product_id, model, total_score, momentum, saturation, differentiation,
                social_proof, margin, logistics, summary, explanations, created_at,
                winner_score_raw, winner_score, winner_score_breakdown
            )
            SELECT
                id, product_id, model, total_score, momentum, saturation, differentiation,
                social_proof, margin, logistics, summary, explanations, created_at,
                winner_score_raw,
                CASE
                    WHEN winner_score IS NULL THEN NULL
                    ELSE CAST(MIN(100, MAX(0, ROUND(winner_score))) AS INTEGER)
                END,
                winner_score_breakdown
            FROM scores_old
            """
        )
        cur.execute("DROP TABLE scores_old")
        cur.execute("PRAGMA table_info(scores)")
        info = cur.fetchall()
        cols = [row[1] for row in info]
    if "winner_score_breakdown" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score_breakdown JSON")
    if "winner_score_v2" in cols:
        cur.execute(
            "UPDATE scores SET winner_score_raw = winner_score_v2 WHERE winner_score_raw IS NULL"
        )
    cur.execute(
        "UPDATE scores SET winner_score = MIN(100, MAX(0, ROUND(((winner_score_raw - 8) / 32.0) * 100))) WHERE winner_score_raw IS NOT NULL AND winner_score IS NULL"
    )
    cur.execute(
        "UPDATE scores SET winner_score_breakdown = '{}' WHERE winner_score_breakdown IS NULL"
    )
    # Lists table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS lists (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE
        )
        """
    )
    # List items table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS list_items (
            list_id INTEGER,
            product_id INTEGER,
            PRIMARY KEY (list_id, product_id),
            FOREIGN KEY(list_id) REFERENCES lists(id) ON DELETE CASCADE,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    # Import jobs table to track asynchronous imports
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS import_jobs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            status TEXT NOT NULL,
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            rows_imported INTEGER DEFAULT 0,
            winner_score_updated INTEGER DEFAULT 0,
            error TEXT,
            temp_path TEXT,
            ai_total INTEGER DEFAULT 0,
            ai_done INTEGER DEFAULT 0,
            ai_error TEXT,
            ai_counts TEXT,
            ai_pending TEXT
        )
        """
    )
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_total INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_done INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_error TEXT")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_counts TEXT")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_pending TEXT")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN winner_score_updated INTEGER DEFAULT 0")
    except Exception:
        pass
    conn.commit()


def insert_product(
    conn: sqlite3.Connection,
    name: str,
    description: Optional[str] = None,
    category: Optional[str] = None,
    price: Optional[float] = None,
    currency: Optional[str] = None,
    image_url: Optional[str] = None,
    source: Optional[str] = None,
    desire: Optional[str] = None,
    desire_magnitude: Optional[str] = None,
    awareness_level: Optional[str] = None,
    competition_level: Optional[str] = None,
    date_range: Optional[str] = None,
    extra: Optional[Dict[str, Any]] = None,
    commit: bool = True,
    product_id: Optional[int] = None,
) -> int:
    """Insert a new product into the database.

    Args:
        conn: SQLite connection
        name: Product name
        description: Optional description
        category: Optional category
        price: Optional numeric price
        currency: Optional currency code
        image_url: Optional URL or path to image
        source: Optional source string describing where the product was imported from
        desire: Short text describing the desire (<=180 characters)
        desire_magnitude: One of 'Low', 'Medium', 'High'
        awareness_level: One of 'Unaware','Problem-Aware','Solution-Aware','Product-Aware','Most Aware'
        competition_level: One of 'Low', 'Medium', 'High'
        extra: Optional dictionary of additional attributes (will be stored as JSON)
        product_id: Explicit ID for the row. If ``None`` the database assigns one.

    Returns:
        The product ID (autoâ€‘generated or explicit).
    """
    cur = conn.cursor()
    import_date = datetime.utcnow().isoformat()
    if desire is not None and len(desire) > 180:
        desire = desire[:180]
    allowed_tri = {"Low", "Medium", "High"}
    if desire_magnitude not in allowed_tri:
        desire_magnitude = None
    if competition_level not in allowed_tri:
        competition_level = None
    allowed_awareness = {
        "Unaware",
        "Problem-Aware",
        "Solution-Aware",
        "Product-Aware",
        "Most Aware",
    }
    if awareness_level not in allowed_awareness:
        awareness_level = None
    if product_id is not None:
        cur.execute(
            """
            INSERT INTO products (
                id, name, description, category, price, currency, image_url, source,
                import_date, desire, desire_magnitude, awareness_level,
                competition_level, date_range, extra)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?))
            """,
            (
                product_id,
                name,
                description,
                category,
                price,
                currency,
                image_url,
                source,
                import_date,
                desire,
                desire_magnitude,
                awareness_level,
                competition_level,
                date_range,
                json_dump(extra) if extra is not None else "{}",
            ),
        )
    else:
        cur.execute(
            """
            INSERT INTO products (
                name, description, category, price, currency, image_url, source,
                import_date, desire, desire_magnitude, awareness_level,
                competition_level, date_range, extra)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?))
            """,
            (
                name,
                description,
                category,
                price,
                currency,
                image_url,
                source,
                import_date,
                desire,
                desire_magnitude,
                awareness_level,
                competition_level,
                date_range,
                json_dump(extra) if extra is not None else "{}",
            ),
        )
    if commit:
        conn.commit()
    return product_id if product_id is not None else cur.lastrowid


def list_products(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all products in the database ordered by import date descending."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products ORDER BY import_date DESC"
    )
    return cur.fetchall()


def get_product(conn: sqlite3.Connection, product_id: int) -> Optional[sqlite3.Row]:
    """Retrieve a product by its ID."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE id = ?",
        (product_id,),
    )
    return cur.fetchone()


def update_product(
    conn: sqlite3.Connection,
    product_id: int,
    **fields: Any,
) -> None:
    """Update an existing product with provided fields.

    Only updates known columns defined in the products table. Unknown keys
    are ignored silently. Validation rules for the four new qualitative
    fields mirror those used in ``insert_product``.
    """

    allowed_cols = {
        "name",
        "description",
        "category",
        "price",
        "currency",
        "image_url",
        "source",
        "desire",
        "desire_magnitude",
        "awareness_level",
        "competition_level",
        "date_range",
        "ai_columns_completed_at",
        "magnitud_deseo",
        "nivel_consciencia_headroom",
        "evidencia_demanda",
        "tasa_conversion",
        "ventas_por_dia",
        "recencia_lanzamiento",
        "competition_level_invertido",
        "facilidad_anuncio",
        "escalabilidad",
        "durabilidad_recurrencia",
    }
    data = {k: v for k, v in fields.items() if k in allowed_cols}
    if not data:
        return
    if "desire" in data and data["desire"] and len(data["desire"]) > 180:
        data["desire"] = data["desire"][:180]
    tri_vals = {"Low", "Medium", "High"}
    if "desire_magnitude" in data and data["desire_magnitude"] not in tri_vals:
        data["desire_magnitude"] = None
    if "competition_level" in data and data["competition_level"] not in tri_vals:
        data["competition_level"] = None
    aware_vals = {
        "Unaware",
        "Problem-Aware",
        "Solution-Aware",
        "Product-Aware",
        "Most Aware",
    }
    if "awareness_level" in data and data["awareness_level"] not in aware_vals:
        data["awareness_level"] = None
    sets = ",".join([f"{k} = ?" for k in data.keys()])
    cur = conn.cursor()
    cur.execute(
        f"UPDATE products SET {sets} WHERE id = ?",
        (*data.values(), product_id),
    )
    conn.commit()


def insert_score(
    conn: sqlite3.Connection,
    product_id: int,
    model: str,
    total_score: float,
    momentum: float,
    saturation: float,
    differentiation: float,
    social_proof: float,
    margin: float,
    logistics: float,
    summary: str,
    explanations: Dict[str, Any],
    winner_score_raw: Optional[float] = None,
    winner_score: Optional[float] = None,
    winner_score_breakdown: Optional[Dict[str, Any]] = None,
    *,
    commit: bool = True,
) -> int:
    """Insert a new AI score for a product."""

    cur = conn.cursor()
    created_at = datetime.utcnow().isoformat()
    if winner_score is not None:
        try:
            pct = int(round(float(winner_score)))
        except Exception:
            pct = 0
        winner_score = max(0, min(100, pct))
        winner_score_raw = 8 + (winner_score / 100.0) * 32
    elif winner_score_raw is not None:
        pct = int(round(((winner_score_raw - 8) / 32.0) * 100))
        winner_score = max(0, min(100, pct))
        winner_score_raw = 8 + (winner_score / 100.0) * 32
    if winner_score_breakdown is None:
        winner_score_breakdown = {}
    cur.execute(
        """
        INSERT INTO scores (
            product_id, model, total_score, momentum, saturation, differentiation,
            social_proof, margin, logistics, summary, explanations, created_at,
            winner_score_raw, winner_score, winner_score_breakdown)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?), ?, ?, ?, json(?))
        """,
        (
            product_id,
            model,
            total_score,
            momentum,
            saturation,
            differentiation,
            social_proof,
            margin,
            logistics,
            summary,
            json_dump(explanations),
            created_at,
            winner_score_raw,
            winner_score,
            json_dump(winner_score_breakdown),
        ),
    )
    if commit:
        conn.commit()
    return cur.lastrowid

def remove_product_from_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Remove association of a product from a list (does not delete the product itself)."""
    cur = conn.cursor()
    cur.execute(
        "DELETE FROM list_items WHERE list_id = ? AND product_id = ?",
        (list_id, product_id),
    )
    conn.commit()


def get_scores_for_product(conn: sqlite3.Connection, product_id: int) -> List[sqlite3.Row]:
    """Retrieve all scores associated with a product."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM scores WHERE product_id = ? ORDER BY created_at DESC",
        (product_id,),
    )
    return cur.fetchall()


def create_list(conn: sqlite3.Connection, name: str) -> int:
    """Create a new list if it does not already exist."""
    cur = conn.cursor()
    try:
        cur.execute(
            "INSERT INTO lists (name) VALUES (?)",
            (name,),
        )
        conn.commit()
        return cur.lastrowid
    except sqlite3.IntegrityError:
        # List name already exists
        cur.execute("SELECT id FROM lists WHERE name = ?", (name,))
        row = cur.fetchone()
        return row["id"] if row else -1


def get_lists(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all lists with product counts."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT l.id, l.name, COUNT(li.product_id) AS count
        FROM lists l
        LEFT JOIN list_items li ON li.list_id = l.id
        GROUP BY l.id
        ORDER BY l.name
        """
    )
    return cur.fetchall()


def add_product_to_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Add a product to a list (idempotent)."""
    cur = conn.cursor()
    cur.execute(
        "INSERT OR IGNORE INTO list_items (list_id, product_id) VALUES (?, ?)",
        (list_id, product_id),
    )
    conn.commit()

def delete_list(
    conn: sqlite3.Connection,
    list_id: int,
    mode: str = "remove",
    target_list_id: int | None = None,
) -> dict:
    """Delete a list with options to detach or move products.

    Args:
        list_id: ID of the list to delete.
        mode: 'remove' to detach products or 'move' to reassign them.
        target_list_id: destination list ID when mode is 'move'.

    Returns:
        Dict summarising the action performed.
    """
    cur = conn.cursor()
    # Ensure list exists and fetch its name
    cur.execute("SELECT id, name FROM lists WHERE id = ?", (list_id,))
    row = cur.fetchone()
    if not row:
        raise ValueError("List not found")

    # Protected lists (by name)
    if row["name"].lower() in {"todos", "all"}:
        raise ValueError("Protected list")

    if mode == "move":
        if target_list_id is None:
            raise ValueError("target_list_id required for move")
        if target_list_id == list_id:
            raise ValueError("target_list_id must be different")
        # Ensure target exists
        cur.execute("SELECT id FROM lists WHERE id = ?", (target_list_id,))
        if not cur.fetchone():
            raise ValueError("Target list not found")
        # Get product ids in source
        cur.execute(
            "SELECT product_id FROM list_items WHERE list_id = ?", (list_id,)
        )
        products = [r[0] for r in cur.fetchall()]
        moved = 0
        for pid in products:
            cur.execute(
                "INSERT OR IGNORE INTO list_items (list_id, product_id) VALUES (?, ?)",
                (target_list_id, pid),
            )
            moved += cur.rowcount
        # Remove old associations and list
        cur.execute("DELETE FROM list_items WHERE list_id = ?", (list_id,))
        cur.execute("DELETE FROM lists WHERE id = ?", (list_id,))
        conn.commit()
        return {"deletedGroup": row["name"], "movedCount": moved}
    else:
        # Remove list; ON DELETE CASCADE cleans associations
        cur.execute(
            "SELECT COUNT(*) FROM list_items WHERE list_id = ?", (list_id,)
        )
        count = cur.fetchone()[0]
        cur.execute("DELETE FROM lists WHERE id = ?", (list_id,))
        conn.commit()
        return {"deletedGroup": row["name"], "detachedCount": count}


def get_products_in_list(conn: sqlite3.Connection, list_id: int) -> List[sqlite3.Row]:
    """Get all products in a particular list."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT p.* FROM products p
        JOIN list_items li ON li.product_id = p.id
        WHERE li.list_id = ?
        ORDER BY p.import_date DESC
        """,
        (list_id,),
    )
    return cur.fetchall()


def json_dump(obj: Any) -> str:
    """Utility to convert Python objects to JSON strings in a predictable way.

    SQLite ships with a JSON1 extension but doesn't include a serializer from Python
    dictionaries.  This helper uses the builtâ€‘in json module to dump objects.
    The ensure_ascii=False flag preserves unicode characters such as accents.
    """
    import json

    return json.dumps(obj or {}, ensure_ascii=False)


def find_product_by_name(conn: sqlite3.Connection, name: str) -> Optional[sqlite3.Row]:
    """
    Find a product by its name, caseâ€‘insensitively.  Returns the row if found or None.

    Args:
        conn: SQLite connection
        name: Product name to search

    Returns:
        A sqlite3.Row object for the first matching product, or None if not found.
    """
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE LOWER(name) = LOWER(?) LIMIT 1",
        (name,),
    )
    return cur.fetchone()


def delete_product(conn: sqlite3.Connection, product_id: int) -> None:
    """
    Delete a product by its ID along with its associated scores and list entries.

    Args:
        conn: SQLite connection
        product_id: ID of the product to delete

    This function relies on foreign key ON DELETE CASCADE to remove scores and list
    associations automatically.
    """
    cur = conn.cursor()
    cur.execute("DELETE FROM products WHERE id = ?", (product_id,))
    conn.commit()


def create_import_job(conn: sqlite3.Connection, temp_path: str) -> int:
    """Create a new pending import job and return its ID."""
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        INSERT INTO import_jobs (status, created_at, updated_at, rows_imported, winner_score_updated, error, temp_path, ai_total, ai_done, ai_error)
        VALUES ('pending', ?, ?, 0, 0, NULL, ?, 0, 0, NULL)
        """,
        (now, now, temp_path),
    )
    conn.commit()
    return cur.lastrowid


def complete_import_job(
    conn: sqlite3.Connection, job_id: int, rows: int, winner_score_updated: int = 0
) -> None:
    """Mark an import job as completed."""
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        UPDATE import_jobs
        SET status='done', updated_at=?, rows_imported=?, winner_score_updated=?, error=NULL
        WHERE id=?
        """,
        (now, rows, winner_score_updated, job_id),
    )
    conn.commit()


def fail_import_job(conn: sqlite3.Connection, job_id: int, error: str) -> None:
    """Mark an import job as failed."""
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        UPDATE import_jobs
        SET status='error', updated_at=?, error=?
        WHERE id=?
        """,
        (now, error, job_id),
    )
    conn.commit()


def start_import_job_ai(conn: sqlite3.Connection, job_id: int, total: int) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        UPDATE import_jobs
        SET status='ai', updated_at=?, ai_total=?, ai_done=0, ai_error=NULL
        WHERE id=?
        """,
        (now, total, job_id),
    )
    conn.commit()


def update_import_job_ai_progress(conn: sqlite3.Connection, job_id: int, done: int) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        "UPDATE import_jobs SET ai_done=?, updated_at=? WHERE id=?",
        (done, now, job_id),
    )
    conn.commit()


def set_import_job_ai_error(conn: sqlite3.Connection, job_id: int, error: str) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        "UPDATE import_jobs SET ai_error=?, updated_at=? WHERE id=?",
        (error, now, job_id),
    )
    conn.commit()


def set_import_job_ai_counts(
    conn: sqlite3.Connection, job_id: int, counts: Dict[str, Any], pending_ids: List[int]
) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        "UPDATE import_jobs SET ai_counts=?, ai_pending=?, updated_at=? WHERE id=?",
        (json.dumps(counts), json.dumps(pending_ids), now, job_id),
    )
    conn.commit()


def get_import_history(conn: sqlite3.Connection, limit: int = 20) -> List[sqlite3.Row]:
    """Return recent import jobs ordered by creation time."""
    cur = conn.cursor()
    cur.execute(
        "SELECT id AS task_id, status, rows_imported, winner_score_updated, created_at, updated_at, error, ai_total, ai_done, ai_error, ai_counts, ai_pending FROM import_jobs ORDER BY created_at DESC LIMIT ?",
        (limit,),
    )
    return cur.fetchall()


def get_import_job(conn: sqlite3.Connection, job_id: int) -> Optional[sqlite3.Row]:
    """Return a single import job by ID."""
    cur = conn.cursor()
    cur.execute(
        "SELECT id AS task_id, status, rows_imported, winner_score_updated, created_at, updated_at, error, ai_total, ai_done, ai_error, ai_counts, ai_pending FROM import_jobs WHERE id=?",
        (job_id,),
    )
    return cur.fetchone()

def mark_stale_pending_imports(conn: sqlite3.Connection, minutes: int) -> None:
    """Mark pending imports older than X minutes as errored after restart."""
    cutoff = (datetime.utcnow() - timedelta(minutes=minutes)).isoformat()
    cur = conn.cursor()
    cur.execute(
        "SELECT id, temp_path FROM import_jobs WHERE status='pending' AND created_at <= ?",
        (cutoff,),
    )
    rows = cur.fetchall()
    for row in rows:
        cur.execute(
            "UPDATE import_jobs SET status='error', updated_at=?, error='server restarted' WHERE id=?",
            (datetime.utcnow().isoformat(), row["id"]),
        )
        if row["temp_path"]:
            try:
                Path(row["temp_path"]).unlink()
            except Exception:
                pass
    conn.commit()