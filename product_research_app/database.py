"""
Database layer for the Product Research Copilot.

This module defines helper functions to manage a local SQLite database.  The database
stores imported products, scores generated by the AI model, user defined lists and
other ancillary data.  Using SQLite allows the entire application to run locally
without any additional infrastructure.  As the project grows the same API can be
adapted to other backends such as PostgreSQL by changing the connection string.

Tables:
    products      -- core table storing product metadata
    scores        -- table storing AI‑generated scores and explanations
    lists         -- table storing user defined collection names
    list_items    -- junction table associating products to lists

All date/time fields are stored as ISO 8601 strings for simplicity.
"""

import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


def get_connection(db_path: Path) -> sqlite3.Connection:
    """Return a SQLite connection to the specified database file.

    The database file will be created if it does not exist.  Foreign key support
    is enabled on every connection.

    Args:
        db_path: Path to the SQLite file.

    Returns:
        A sqlite3.Connection object.
    """
    conn = sqlite3.connect(str(db_path))
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    return conn


def initialize_database(conn: sqlite3.Connection) -> None:
    """Create tables if they do not exist.

    This function can be run repeatedly; it will only create missing tables.

    Args:
        conn: A SQLite connection instance.
    """
    cur = conn.cursor()
    # Products table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            description TEXT,
            category TEXT,
            price REAL,
            currency TEXT,
            image_url TEXT,
            source TEXT,
            import_date TEXT NOT NULL,
            extra JSON
        )
        """
    )
    # Scores table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS scores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            product_id INTEGER NOT NULL,
            model TEXT NOT NULL,
            total_score REAL,
            momentum REAL,
            saturation REAL,
            differentiation REAL,
            social_proof REAL,
            margin REAL,
            logistics REAL,
            summary TEXT,
            explanations JSON,
            created_at TEXT NOT NULL,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    # Lists table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS lists (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE
        )
        """
    )
    # List items table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS list_items (
            list_id INTEGER,
            product_id INTEGER,
            PRIMARY KEY (list_id, product_id),
            FOREIGN KEY(list_id) REFERENCES lists(id) ON DELETE CASCADE,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    conn.commit()


def insert_product(
    conn: sqlite3.Connection,
    name: str,
    description: Optional[str] = None,
    category: Optional[str] = None,
    price: Optional[float] = None,
    currency: Optional[str] = None,
    image_url: Optional[str] = None,
    source: Optional[str] = None,
    extra: Optional[Dict[str, Any]] = None,
) -> int:
    """Insert a new product into the database.

    Args:
        conn: SQLite connection
        name: Product name
        description: Optional description
        category: Optional category
        price: Optional numeric price
        currency: Optional currency code
        image_url: Optional URL or path to image
        source: Optional source string describing where the product was imported from
        extra: Optional dictionary of additional attributes (will be stored as JSON)

    Returns:
        The auto‑generated product ID.
    """
    cur = conn.cursor()
    import_date = datetime.utcnow().isoformat()
    cur.execute(
        """
        INSERT INTO products (name, description, category, price, currency, image_url, source, import_date, extra)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, json(?))
        """,
        (
            name,
            description,
            category,
            price,
            currency,
            image_url,
            source,
            import_date,
            json_dump(extra) if extra is not None else "{}",
        ),
    )
    conn.commit()
    return cur.lastrowid


def list_products(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all products in the database ordered by import date descending."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products ORDER BY import_date DESC"
    )
    return cur.fetchall()


def get_product(conn: sqlite3.Connection, product_id: int) -> Optional[sqlite3.Row]:
    """Retrieve a product by its ID."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE id = ?",
        (product_id,),
    )
    return cur.fetchone()


def insert_score(
    conn: sqlite3.Connection,
    product_id: int,
    model: str,
    total_score: float,
    momentum: float,
    saturation: float,
    differentiation: float,
    social_proof: float,
    margin: float,
    logistics: float,
    summary: str,
    explanations: Dict[str, Any],
) -> int:
    """Insert a new AI score for a product."""
    cur = conn.cursor()
    created_at = datetime.utcnow().isoformat()
    cur.execute(
        """
        INSERT INTO scores (
            product_id, model, total_score, momentum, saturation, differentiation,
            social_proof, margin, logistics, summary, explanations, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?), ?)
        """,
        (
            product_id,
            model,
            total_score,
            momentum,
            saturation,
            differentiation,
            social_proof,
            margin,
            logistics,
            summary,
            json_dump(explanations),
            created_at,
        ),
    )
    conn.commit()
    return cur.lastrowid

def remove_product_from_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Remove association of a product from a list (does not delete the product itself)."""
    cur = conn.cursor()
    cur.execute(
        "DELETE FROM list_items WHERE list_id = ? AND product_id = ?",
        (list_id, product_id),
    )
    conn.commit()


def get_scores_for_product(conn: sqlite3.Connection, product_id: int) -> List[sqlite3.Row]:
    """Retrieve all scores associated with a product."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM scores WHERE product_id = ? ORDER BY created_at DESC",
        (product_id,),
    )
    return cur.fetchall()


def create_list(conn: sqlite3.Connection, name: str) -> int:
    """Create a new list if it does not already exist."""
    cur = conn.cursor()
    try:
        cur.execute(
            "INSERT INTO lists (name) VALUES (?)",
            (name,),
        )
        conn.commit()
        return cur.lastrowid
    except sqlite3.IntegrityError:
        # List name already exists
        cur.execute("SELECT id FROM lists WHERE name = ?", (name,))
        row = cur.fetchone()
        return row["id"] if row else -1


def get_lists(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all lists."""
    cur = conn.cursor()
    cur.execute("SELECT * FROM lists ORDER BY name")
    return cur.fetchall()


def add_product_to_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Add a product to a list (idempotent)."""
    cur = conn.cursor()
    cur.execute(
        "INSERT OR IGNORE INTO list_items (list_id, product_id) VALUES (?, ?)",
        (list_id, product_id),
    )
    conn.commit()

def delete_list(conn: sqlite3.Connection, list_id: int) -> None:
    """Delete a list by its ID, along with its associations."""
    cur = conn.cursor()
    cur.execute("DELETE FROM lists WHERE id = ?", (list_id,))
    conn.commit()


def get_products_in_list(conn: sqlite3.Connection, list_id: int) -> List[sqlite3.Row]:
    """Get all products in a particular list."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT p.* FROM products p
        JOIN list_items li ON li.product_id = p.id
        WHERE li.list_id = ?
        ORDER BY p.import_date DESC
        """,
        (list_id,),
    )
    return cur.fetchall()


def json_dump(obj: Any) -> str:
    """Utility to convert Python objects to JSON strings in a predictable way.

    SQLite ships with a JSON1 extension but doesn't include a serializer from Python
    dictionaries.  This helper uses the built‑in json module to dump objects.
    The ensure_ascii=False flag preserves unicode characters such as accents.
    """
    import json

    return json.dumps(obj or {}, ensure_ascii=False)


def find_product_by_name(conn: sqlite3.Connection, name: str) -> Optional[sqlite3.Row]:
    """
    Find a product by its name, case‑insensitively.  Returns the row if found or None.

    Args:
        conn: SQLite connection
        name: Product name to search

    Returns:
        A sqlite3.Row object for the first matching product, or None if not found.
    """
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE LOWER(name) = LOWER(?) LIMIT 1",
        (name,),
    )
    return cur.fetchone()


def delete_product(conn: sqlite3.Connection, product_id: int) -> None:
    """
    Delete a product by its ID along with its associated scores and list entries.

    Args:
        conn: SQLite connection
        product_id: ID of the product to delete

    This function relies on foreign key ON DELETE CASCADE to remove scores and list
    associations automatically.
    """
    cur = conn.cursor()
    cur.execute("DELETE FROM products WHERE id = ?", (product_id,))
    conn.commit()