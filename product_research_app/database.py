"""
Database layer for the Product Research Copilot.

This module defines helper functions to manage a local SQLite database.  The database
stores imported products, scores generated by the AI model, user defined lists and
other ancillary data.  Using SQLite allows the entire application to run locally
without any additional infrastructure.  As the project grows the same API can be
adapted to other backends such as PostgreSQL by changing the connection string.

Tables:
    products      -- core table storing product metadata
    scores        -- table storing AI‑generated scores and explanations
    lists         -- table storing user defined collection names
    list_items    -- junction table associating products to lists

All date/time fields are stored as ISO 8601 strings for simplicity.
"""

import sqlite3
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


def get_connection(db_path: Path) -> sqlite3.Connection:
    """Return a SQLite connection to the specified database file.

    The database file will be created if it does not exist.  Foreign key support
    is enabled on every connection.

    Args:
        db_path: Path to the SQLite file.

    Returns:
        A sqlite3.Connection object.
    """
    conn = sqlite3.connect(str(db_path))
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    return conn


def initialize_database(conn: sqlite3.Connection) -> None:
    """Create tables if they do not exist.

    This function can be run repeatedly; it will only create missing tables.

    Args:
        conn: A SQLite connection instance.
    """
    cur = conn.cursor()
    # Products table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            description TEXT,
            category TEXT,
            price REAL,
            currency TEXT,
            image_url TEXT,
            source TEXT,
            import_date TEXT NOT NULL,
            extra JSON
        )
        """
    )
    # Scores table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS scores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            product_id INTEGER NOT NULL,
            model TEXT NOT NULL,
            total_score REAL,
            momentum REAL,
            saturation REAL,
            differentiation REAL,
            social_proof REAL,
            margin REAL,
            logistics REAL,
            summary TEXT,
            explanations JSON,
            created_at TEXT NOT NULL,
            winner_score_v2_raw REAL,
            winner_score_v2_pct REAL,
            winner_score_v2_breakdown JSON,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    cur.execute("PRAGMA table_info(scores)")
    cols = [row[1] for row in cur.fetchall()]
    if "winner_score_v2_raw" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score_v2_raw REAL")
    if "winner_score_v2_pct" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score_v2_pct REAL")
    if "winner_score_v2_breakdown" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score_v2_breakdown JSON")
    if "winner_score_v2" in cols:
        cur.execute(
            "UPDATE scores SET winner_score_v2_raw = winner_score_v2 WHERE winner_score_v2_raw IS NULL"
        )
    cur.execute(
        "UPDATE scores SET winner_score_v2_pct = ((winner_score_v2_raw - 8) / 32.0) * 100 WHERE winner_score_v2_raw IS NOT NULL AND winner_score_v2_pct IS NULL"
    )
    cur.execute(
        "UPDATE scores SET winner_score_v2_breakdown = '{}' WHERE winner_score_v2_breakdown IS NULL"
    )
    # Lists table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS lists (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE
        )
        """
    )
    # List items table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS list_items (
            list_id INTEGER,
            product_id INTEGER,
            PRIMARY KEY (list_id, product_id),
            FOREIGN KEY(list_id) REFERENCES lists(id) ON DELETE CASCADE,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    conn.commit()


def insert_product(
    conn: sqlite3.Connection,
    name: str,
    description: Optional[str] = None,
    category: Optional[str] = None,
    price: Optional[float] = None,
    currency: Optional[str] = None,
    image_url: Optional[str] = None,
    source: Optional[str] = None,
    extra: Optional[Dict[str, Any]] = None,
) -> int:
    """Insert a new product into the database.

    Args:
        conn: SQLite connection
        name: Product name
        description: Optional description
        category: Optional category
        price: Optional numeric price
        currency: Optional currency code
        image_url: Optional URL or path to image
        source: Optional source string describing where the product was imported from
        extra: Optional dictionary of additional attributes (will be stored as JSON)

    Returns:
        The auto‑generated product ID.
    """
    cur = conn.cursor()
    import_date = datetime.utcnow().isoformat()
    cur.execute(
        """
        INSERT INTO products (name, description, category, price, currency, image_url, source, import_date, extra)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, json(?))
        """,
        (
            name,
            description,
            category,
            price,
            currency,
            image_url,
            source,
            import_date,
            json_dump(extra) if extra is not None else "{}",
        ),
    )
    conn.commit()
    return cur.lastrowid


def list_products(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all products in the database ordered by import date descending."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products ORDER BY import_date DESC"
    )
    return cur.fetchall()


def get_product(conn: sqlite3.Connection, product_id: int) -> Optional[sqlite3.Row]:
    """Retrieve a product by its ID."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE id = ?",
        (product_id,),
    )
    return cur.fetchone()


def insert_score(
    conn: sqlite3.Connection,
    product_id: int,
    model: str,
    total_score: float,
    momentum: float,
    saturation: float,
    differentiation: float,
    social_proof: float,
    margin: float,
    logistics: float,
    summary: str,
    explanations: Dict[str, Any],
    winner_score_v2_raw: Optional[float] = None,
    winner_score_v2_pct: Optional[float] = None,
    winner_score_v2_breakdown: Optional[Dict[str, Any]] = None,
) -> int:
    """Insert a new AI score for a product."""

    cur = conn.cursor()
    created_at = datetime.utcnow().isoformat()
    if winner_score_v2_raw is None and winner_score_v2_pct is not None:
        winner_score_v2_raw = 8 + (winner_score_v2_pct / 100.0) * 32
    if winner_score_v2_pct is None and winner_score_v2_raw is not None:
        winner_score_v2_pct = ((winner_score_v2_raw - 8) / 32.0) * 100
    if winner_score_v2_breakdown is None:
        winner_score_v2_breakdown = {}
    cur.execute(
        """
        INSERT INTO scores (
            product_id, model, total_score, momentum, saturation, differentiation,
            social_proof, margin, logistics, summary, explanations, created_at,
            winner_score_v2_raw, winner_score_v2_pct, winner_score_v2_breakdown)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?), ?, ?, ?, json(?))
        """,
        (
            product_id,
            model,
            total_score,
            momentum,
            saturation,
            differentiation,
            social_proof,
            margin,
            logistics,
            summary,
            json_dump(explanations),
            created_at,
            winner_score_v2_raw,
            winner_score_v2_pct,
            json_dump(winner_score_v2_breakdown),
        ),
    )
    conn.commit()
    return cur.lastrowid

def remove_product_from_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Remove association of a product from a list (does not delete the product itself)."""
    cur = conn.cursor()
    cur.execute(
        "DELETE FROM list_items WHERE list_id = ? AND product_id = ?",
        (list_id, product_id),
    )
    conn.commit()


def get_scores_for_product(conn: sqlite3.Connection, product_id: int) -> List[sqlite3.Row]:
    """Retrieve all scores associated with a product."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM scores WHERE product_id = ? ORDER BY created_at DESC",
        (product_id,),
    )
    return cur.fetchall()


def create_list(conn: sqlite3.Connection, name: str) -> int:
    """Create a new list if it does not already exist."""
    cur = conn.cursor()
    try:
        cur.execute(
            "INSERT INTO lists (name) VALUES (?)",
            (name,),
        )
        conn.commit()
        return cur.lastrowid
    except sqlite3.IntegrityError:
        # List name already exists
        cur.execute("SELECT id FROM lists WHERE name = ?", (name,))
        row = cur.fetchone()
        return row["id"] if row else -1


def get_lists(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all lists with product counts."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT l.id, l.name, COUNT(li.product_id) AS count
        FROM lists l
        LEFT JOIN list_items li ON li.list_id = l.id
        GROUP BY l.id
        ORDER BY l.name
        """
    )
    return cur.fetchall()


def add_product_to_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Add a product to a list (idempotent)."""
    cur = conn.cursor()
    cur.execute(
        "INSERT OR IGNORE INTO list_items (list_id, product_id) VALUES (?, ?)",
        (list_id, product_id),
    )
    conn.commit()

def delete_list(
    conn: sqlite3.Connection,
    list_id: int,
    mode: str = "remove",
    target_list_id: int | None = None,
) -> dict:
    """Delete a list with options to detach or move products.

    Args:
        list_id: ID of the list to delete.
        mode: 'remove' to detach products or 'move' to reassign them.
        target_list_id: destination list ID when mode is 'move'.

    Returns:
        Dict summarising the action performed.
    """
    cur = conn.cursor()
    # Ensure list exists and fetch its name
    cur.execute("SELECT id, name FROM lists WHERE id = ?", (list_id,))
    row = cur.fetchone()
    if not row:
        raise ValueError("List not found")

    # Protected lists (by name)
    if row["name"].lower() in {"todos", "all"}:
        raise ValueError("Protected list")

    if mode == "move":
        if target_list_id is None:
            raise ValueError("target_list_id required for move")
        if target_list_id == list_id:
            raise ValueError("target_list_id must be different")
        # Ensure target exists
        cur.execute("SELECT id FROM lists WHERE id = ?", (target_list_id,))
        if not cur.fetchone():
            raise ValueError("Target list not found")
        # Get product ids in source
        cur.execute(
            "SELECT product_id FROM list_items WHERE list_id = ?", (list_id,)
        )
        products = [r[0] for r in cur.fetchall()]
        moved = 0
        for pid in products:
            cur.execute(
                "INSERT OR IGNORE INTO list_items (list_id, product_id) VALUES (?, ?)",
                (target_list_id, pid),
            )
            moved += cur.rowcount
        # Remove old associations and list
        cur.execute("DELETE FROM list_items WHERE list_id = ?", (list_id,))
        cur.execute("DELETE FROM lists WHERE id = ?", (list_id,))
        conn.commit()
        return {"deletedGroup": row["name"], "movedCount": moved}
    else:
        # Remove list; ON DELETE CASCADE cleans associations
        cur.execute(
            "SELECT COUNT(*) FROM list_items WHERE list_id = ?", (list_id,)
        )
        count = cur.fetchone()[0]
        cur.execute("DELETE FROM lists WHERE id = ?", (list_id,))
        conn.commit()
        return {"deletedGroup": row["name"], "detachedCount": count}


def get_products_in_list(conn: sqlite3.Connection, list_id: int) -> List[sqlite3.Row]:
    """Get all products in a particular list."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT p.* FROM products p
        JOIN list_items li ON li.product_id = p.id
        WHERE li.list_id = ?
        ORDER BY p.import_date DESC
        """,
        (list_id,),
    )
    return cur.fetchall()


def json_dump(obj: Any) -> str:
    """Utility to convert Python objects to JSON strings in a predictable way.

    SQLite ships with a JSON1 extension but doesn't include a serializer from Python
    dictionaries.  This helper uses the built‑in json module to dump objects.
    The ensure_ascii=False flag preserves unicode characters such as accents.
    """
    import json

    return json.dumps(obj or {}, ensure_ascii=False)


def find_product_by_name(conn: sqlite3.Connection, name: str) -> Optional[sqlite3.Row]:
    """
    Find a product by its name, case‑insensitively.  Returns the row if found or None.

    Args:
        conn: SQLite connection
        name: Product name to search

    Returns:
        A sqlite3.Row object for the first matching product, or None if not found.
    """
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE LOWER(name) = LOWER(?) LIMIT 1",
        (name,),
    )
    return cur.fetchone()


def delete_product(conn: sqlite3.Connection, product_id: int) -> None:
    """
    Delete a product by its ID along with its associated scores and list entries.

    Args:
        conn: SQLite connection
        product_id: ID of the product to delete

    This function relies on foreign key ON DELETE CASCADE to remove scores and list
    associations automatically.
    """
    cur = conn.cursor()
    cur.execute("DELETE FROM products WHERE id = ?", (product_id,))
    conn.commit()