"""
Database layer for the Product Research Copilot.

This module defines helper functions to manage a local SQLite database.  The database
stores imported products, scores generated by the AI model, user defined lists and
other ancillary data.  Using SQLite allows the entire application to run locally
without any additional infrastructure.  As the project grows the same API can be
adapted to other backends such as PostgreSQL by changing the connection string.

Tables:
    products      -- core table storing product metadata
    scores        -- table storing AI‑generated scores and explanations
    lists         -- table storing user defined collection names
    list_items    -- junction table associating products to lists

All date/time fields are stored as ISO 8601 strings for simplicity.
"""

import json
import sqlite3
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


def get_connection(db_path: Path) -> sqlite3.Connection:
    """Return a SQLite connection to the specified database file.

    The database file will be created if it does not exist.  Foreign key support
    is enabled on every connection.

    Args:
        db_path: Path to the SQLite file.

    Returns:
        A sqlite3.Connection object.
    """
    conn = sqlite3.connect(str(db_path))
    conn.row_factory = sqlite3.Row
    # Enable pragmas for reliability and performance
    conn.execute("PRAGMA journal_mode=WAL")
    conn.execute("PRAGMA synchronous=NORMAL")
    conn.execute("PRAGMA foreign_keys=ON")
    return conn


def initialize_database(conn: sqlite3.Connection) -> None:
    """Create tables if they do not exist.

    This function can be run repeatedly; it will only create missing tables.

    Args:
        conn: A SQLite connection instance.
    """
    cur = conn.cursor()
    # Products table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            description TEXT,
            category TEXT,
            price REAL,
            currency TEXT,
            image_url TEXT,
            source TEXT,
            import_date TEXT NOT NULL,
            desire TEXT,
            desire_magnitude TEXT,
            awareness_level TEXT,
            competition_level TEXT,
            date_range TEXT,
            extra JSON,
            winner_score_raw REAL,
            winner_score INTEGER NOT NULL DEFAULT 0,
            winner_score_updated_at TEXT
        )
        """
    )
    cur.execute("PRAGMA table_info(products)")
    cols = [row[1] for row in cur.fetchall()]
    if "desire" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN desire TEXT")
    if "desire_magnitude" not in cols and "magnitud_deseo" in cols:
        cur.execute("ALTER TABLE products RENAME COLUMN magnitud_deseo TO desire_magnitude")
    elif "desire_magnitude" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN desire_magnitude TEXT")
    if "awareness_level" not in cols and "nivel_consciencia" in cols:
        cur.execute("ALTER TABLE products RENAME COLUMN nivel_consciencia TO awareness_level")
    elif "awareness_level" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN awareness_level TEXT")
    if "competition_level" not in cols and "saturacion_mercado" in cols:
        cur.execute("ALTER TABLE products RENAME COLUMN saturacion_mercado TO competition_level")
    elif "competition_level" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN competition_level TEXT")
    if "date_range" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN date_range TEXT")
    if "ai_columns_completed_at" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN ai_columns_completed_at TEXT")
    if "winner_score_v2" in cols and "winner_score" not in cols:
        cur.execute("ALTER TABLE products RENAME COLUMN winner_score_v2 TO winner_score")
        cols = ["winner_score" if c == "winner_score_v2" else c for c in cols]
    if "winner_score" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN winner_score INTEGER NOT NULL DEFAULT 0")
    if "winner_score_raw" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN winner_score_raw REAL")
    if "winner_score_updated_at" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN winner_score_updated_at TEXT")
    if "sig_hash" not in cols:
        cur.execute("ALTER TABLE products ADD COLUMN sig_hash TEXT")
    cur.execute("CREATE UNIQUE INDEX IF NOT EXISTS idx_products_sig_hash ON products(sig_hash)")
    metric_text_cols = [
        "magnitud_deseo",
        "nivel_consciencia_headroom",
        "competition_level_invertido",
        "facilidad_anuncio",
        "escalabilidad",
        "durabilidad_recurrencia",
    ]
    metric_real_cols = [
        "evidencia_demanda",
        "tasa_conversion",
        "ventas_por_dia",
        "recencia_lanzamiento",
    ]
    for col in metric_text_cols:
        if col not in cols:
            cur.execute(f"ALTER TABLE products ADD COLUMN {col} TEXT")
    for col in metric_real_cols:
        if col not in cols:
            cur.execute(f"ALTER TABLE products ADD COLUMN {col} REAL")
    # drop obsolete columns if present
    for obsolete in [
        "facilidad_logistica",
        "engagement_shareability",
        "winner_score_v1",
        "score_v1",
        "ws_v1",
        "winner_score_version",
    ]:
        if obsolete in cols:
            try:
                cur.execute(f"ALTER TABLE products DROP COLUMN {obsolete}")
            except Exception:
                pass
    # Scores table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS scores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            product_id INTEGER NOT NULL,
            model TEXT NOT NULL,
            total_score REAL,
            momentum REAL,
            saturation REAL,
            differentiation REAL,
            social_proof REAL,
            margin REAL,
            logistics REAL,
            summary TEXT,
            explanations JSON,
            created_at TEXT NOT NULL,
            winner_score_raw REAL,
            winner_score INTEGER,
            winner_score_breakdown JSON,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    cur.execute("PRAGMA table_info(scores)")
    info = cur.fetchall()
    cols = [row[1] for row in info]
    colinfo = {row[1]: row for row in info}
    if "winner_score_v2" in cols and "winner_score" not in cols:
        cur.execute("ALTER TABLE scores RENAME COLUMN winner_score_v2 TO winner_score")
        cur.execute("PRAGMA table_info(scores)")
        info = cur.fetchall()
        cols = [row[1] for row in info]
        colinfo = {row[1]: row for row in info}
    if "winner_score_raw" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score_raw REAL")
        cur.execute("PRAGMA table_info(scores)")
        info = cur.fetchall()
        cols = [row[1] for row in info]
        colinfo = {row[1]: row for row in info}
    if "winner_score_v2" in cols:
        cur.execute(
            "UPDATE scores SET winner_score_raw = winner_score_v2 WHERE winner_score_raw IS NULL"
        )
    ws = colinfo.get("winner_score")
    if ws is None:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score INTEGER NOT NULL DEFAULT 0")
    elif ws[2].upper() != "INTEGER" or ws[3] != 1 or (ws[4] is None or str(ws[4]).strip() not in {"0", "0.0"}):
        cur.execute("ALTER TABLE scores RENAME TO scores_old")
        cur.execute(
            """
            CREATE TABLE scores (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                product_id INTEGER NOT NULL,
                model TEXT NOT NULL,
                total_score REAL,
                momentum REAL,
                saturation REAL,
                differentiation REAL,
                social_proof REAL,
                margin REAL,
                logistics REAL,
                summary TEXT,
                explanations JSON,
                created_at TEXT NOT NULL,
                winner_score_raw REAL,
                winner_score INTEGER NOT NULL DEFAULT 0,
                winner_score_breakdown JSON,
                FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
            )
            """
        )
        cur.execute(
            """
            INSERT INTO scores (
                id, product_id, model, total_score, momentum, saturation, differentiation,
                social_proof, margin, logistics, summary, explanations, created_at,
                winner_score_raw, winner_score, winner_score_breakdown
            )
            SELECT
                id, product_id, model, total_score, momentum, saturation, differentiation,
                social_proof, margin, logistics, summary, explanations, created_at,
                winner_score_raw,
                CASE
                    WHEN winner_score IS NULL THEN 0
                    ELSE CAST(MIN(100, MAX(0, ROUND(winner_score))) AS INTEGER)
                END,
                winner_score_breakdown
            FROM scores_old
            """
        )
        cur.execute("DROP TABLE scores_old")
        cur.execute("PRAGMA table_info(scores)")
        info = cur.fetchall()
        cols = [row[1] for row in info]
    if "winner_score_breakdown" not in cols:
        cur.execute("ALTER TABLE scores ADD COLUMN winner_score_breakdown JSON")
    if "winner_score_v2" in cols and "winner_score" in cols:
        cur.execute(
            "UPDATE scores SET winner_score = winner_score_v2 WHERE winner_score IS NULL OR winner_score = 0"
        )
    for obsolete in [
        "winner_score_v1",
        "score_v1",
        "ws_v1",
        "winner_score_version",
        "winner_score_v2",
    ]:
        if obsolete in cols:
            try:
                cur.execute(f"ALTER TABLE scores DROP COLUMN {obsolete}")
            except Exception:
                pass
    cur.execute(
        "UPDATE scores SET winner_score = MIN(100, MAX(0, ROUND(((winner_score_raw - 8) / 32.0) * 100))) WHERE winner_score_raw IS NOT NULL"
    )
    cur.execute(
        "UPDATE scores SET winner_score_breakdown = '{}' WHERE winner_score_breakdown IS NULL",
    )
    # Lists table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS lists (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE
        )
        """
    )
    # List items table
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS list_items (
            list_id INTEGER,
            product_id INTEGER,
            PRIMARY KEY (list_id, product_id),
            FOREIGN KEY(list_id) REFERENCES lists(id) ON DELETE CASCADE,
            FOREIGN KEY(product_id) REFERENCES products(id) ON DELETE CASCADE
        )
        """
    )
    # Import jobs table to track asynchronous imports
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS import_jobs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            status TEXT NOT NULL,
            phase TEXT NOT NULL DEFAULT 'parse',
            created_at TEXT NOT NULL,
            updated_at TEXT NOT NULL,
            total INTEGER DEFAULT 0,
            processed INTEGER DEFAULT 0,
            rows_imported INTEGER DEFAULT 0,
            winner_score_updated INTEGER DEFAULT 0,
            error TEXT,
            temp_path TEXT,
            config JSON,
            budget_cents INTEGER,
            metrics JSON,
            ai_total INTEGER DEFAULT 0,
            ai_done INTEGER DEFAULT 0,
            ai_error TEXT,
            ai_counts TEXT,
            ai_pending TEXT
        )
        """
    )
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_total INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_done INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_error TEXT")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_counts TEXT")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN ai_pending TEXT")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN winner_score_updated INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN phase TEXT DEFAULT 'parse'")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN total INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN processed INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN config JSON")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN budget_cents INTEGER")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE import_jobs ADD COLUMN metrics JSON")
    except Exception:
        pass
    try:
        cur.execute("CREATE INDEX IF NOT EXISTS idx_import_jobs_phase ON import_jobs(phase)")
    except Exception:
        pass

    # Staging table for high volume imports
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS products_staging (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            job_id INTEGER NOT NULL,
            sig_hash TEXT NOT NULL,
            name TEXT NOT NULL,
            description TEXT,
            category TEXT,
            price REAL,
            currency TEXT,
            image_url TEXT,
            brand TEXT,
            asin TEXT,
            product_url TEXT,
            source TEXT,
            import_date TEXT NOT NULL,
            desire TEXT,
            desire_magnitude TEXT,
            awareness_level TEXT,
            competition_level TEXT,
            date_range TEXT,
            winner_score INTEGER,
            extra JSON,
            FOREIGN KEY(job_id) REFERENCES import_jobs(id) ON DELETE CASCADE
        )
        """
    )
    cur.execute("CREATE INDEX IF NOT EXISTS idx_products_staging_job ON products_staging(job_id)")
    cur.execute(
        "CREATE UNIQUE INDEX IF NOT EXISTS idx_products_staging_job_sig ON products_staging(job_id, sig_hash)"
    )

    # Import job items to track row state transitions
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            job_id INTEGER NOT NULL,
            sig_hash TEXT NOT NULL,
            raw JSON NOT NULL,
            state TEXT NOT NULL CHECK(state IN ('raw','pending_enrich','enriched','failed')),
            updated_at TEXT NOT NULL,
            FOREIGN KEY(job_id) REFERENCES import_jobs(id) ON DELETE CASCADE
        )
        """
    )
    cur.execute("CREATE INDEX IF NOT EXISTS idx_items_job ON items(job_id)")
    cur.execute("CREATE INDEX IF NOT EXISTS idx_items_state ON items(state)")

    # Batch metrics for observability
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS import_job_metrics (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            job_id INTEGER NOT NULL,
            batch_no INTEGER NOT NULL,
            rows INTEGER NOT NULL,
            duration_ms REAL NOT NULL,
            throughput REAL NOT NULL,
            created_at TEXT NOT NULL DEFAULT (datetime('now')),
            FOREIGN KEY(job_id) REFERENCES import_jobs(id) ON DELETE CASCADE
        )
        """
    )
    cur.execute("CREATE INDEX IF NOT EXISTS idx_import_job_metrics_job ON import_job_metrics(job_id)")
    conn.commit()


def insert_product(
    conn: sqlite3.Connection,
    name: str,
    description: Optional[str] = None,
    category: Optional[str] = None,
    price: Optional[float] = None,
    currency: Optional[str] = None,
    image_url: Optional[str] = None,
    source: Optional[str] = None,
    desire: Optional[str] = None,
    desire_magnitude: Optional[str] = None,
    awareness_level: Optional[str] = None,
    competition_level: Optional[str] = None,
    date_range: Optional[str] = None,
    extra: Optional[Dict[str, Any]] = None,
    commit: bool = True,
    product_id: Optional[int] = None,
    sig_hash: Optional[str] = None,
) -> int:
    """Insert a new product into the database.

    Args:
        conn: SQLite connection
        name: Product name
        description: Optional description
        category: Optional category
        price: Optional numeric price
        currency: Optional currency code
        image_url: Optional URL or path to image
        source: Optional source string describing where the product was imported from
        desire: Optional text describing the desire
        desire_magnitude: One of 'Low', 'Medium', 'High'
        awareness_level: One of 'Unaware','Problem-Aware','Solution-Aware','Product-Aware','Most Aware'
        competition_level: One of 'Low', 'Medium', 'High'
        extra: Optional dictionary of additional attributes (will be stored as JSON)
        product_id: Explicit ID for the row. If ``None`` the database assigns one.

    Returns:
        The product ID (auto‑generated or explicit).
    """
    cur = conn.cursor()
    import_date = datetime.utcnow().isoformat()
    allowed_tri = {"Low", "Medium", "High"}
    if desire_magnitude not in allowed_tri:
        desire_magnitude = None
    if competition_level not in allowed_tri:
        competition_level = None
    allowed_awareness = {
        "Unaware",
        "Problem-Aware",
        "Solution-Aware",
        "Product-Aware",
        "Most Aware",
    }
    if awareness_level not in allowed_awareness:
        awareness_level = None
    if product_id is not None:
        cur.execute(
            """
            INSERT INTO products (
                id, name, description, category, price, currency, image_url, source,
                import_date, desire, desire_magnitude, awareness_level,
                competition_level, date_range, extra, sig_hash)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?), ?)
            """,
            (
                product_id,
                name,
                description,
                category,
                price,
                currency,
                image_url,
                source,
                import_date,
                desire,
                desire_magnitude,
                awareness_level,
                competition_level,
                date_range,
                json_dump(extra) if extra is not None else "{}",
                sig_hash,
            ),
        )
    else:
        cur.execute(
            """
            INSERT INTO products (
                name, description, category, price, currency, image_url, source,
                import_date, desire, desire_magnitude, awareness_level,
                competition_level, date_range, extra, sig_hash)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?), ?)
            """,
            (
                name,
                description,
                category,
                price,
                currency,
                image_url,
                source,
                import_date,
                desire,
                desire_magnitude,
                awareness_level,
                competition_level,
                date_range,
                json_dump(extra) if extra is not None else "{}",
                sig_hash,
            ),
        )
    if commit:
        conn.commit()
    return product_id if product_id is not None else cur.lastrowid


def list_products(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all products in the database ordered by import date descending."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products ORDER BY import_date DESC"
    )
    return cur.fetchall()


def get_product(conn: sqlite3.Connection, product_id: int) -> Optional[sqlite3.Row]:
    """Retrieve a product by its ID."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE id = ?",
        (product_id,),
    )
    return cur.fetchone()


def update_product(
    conn: sqlite3.Connection,
    product_id: int,
    **fields: Any,
) -> None:
    """Update an existing product with provided fields.

    Only updates known columns defined in the products table. Unknown keys
    are ignored silently. Validation rules for the four new qualitative
    fields mirror those used in ``insert_product``.
    """

    allowed_cols = {
        "name",
        "description",
        "category",
        "price",
        "currency",
        "image_url",
        "source",
        "desire",
        "desire_magnitude",
        "awareness_level",
        "competition_level",
        "date_range",
        "ai_columns_completed_at",
        "magnitud_deseo",
        "nivel_consciencia_headroom",
        "evidencia_demanda",
        "tasa_conversion",
        "ventas_por_dia",
        "recencia_lanzamiento",
        "competition_level_invertido",
        "facilidad_anuncio",
        "escalabilidad",
        "durabilidad_recurrencia",
    }
    data = {k: v for k, v in fields.items() if k in allowed_cols}
    if not data:
        return
    tri_vals = {"Low", "Medium", "High"}
    if "desire_magnitude" in data and data["desire_magnitude"] not in tri_vals:
        data["desire_magnitude"] = None
    if "competition_level" in data and data["competition_level"] not in tri_vals:
        data["competition_level"] = None
    aware_vals = {
        "Unaware",
        "Problem-Aware",
        "Solution-Aware",
        "Product-Aware",
        "Most Aware",
    }
    if "awareness_level" in data and data["awareness_level"] not in aware_vals:
        data["awareness_level"] = None
    sets = ",".join([f"{k} = ?" for k in data.keys()])
    cur = conn.cursor()
    cur.execute(
        f"UPDATE products SET {sets} WHERE id = ?",
        (*data.values(), product_id),
    )
    conn.commit()


def insert_score(
    conn: sqlite3.Connection,
    product_id: int,
    model: str,
    total_score: float,
    momentum: float,
    saturation: float,
    differentiation: float,
    social_proof: float,
    margin: float,
    logistics: float,
    summary: str,
    explanations: Dict[str, Any],
    winner_score_raw: Optional[float] = None,
    winner_score: Optional[float] = None,
    winner_score_breakdown: Optional[Dict[str, Any]] = None,
    *,
    commit: bool = True,
) -> int:
    """Insert a new AI score for a product."""

    cur = conn.cursor()
    created_at = datetime.utcnow().isoformat()
    if winner_score is not None:
        try:
            pct = int(round(float(winner_score)))
        except Exception:
            pct = 0
        winner_score = max(0, min(100, pct))
        winner_score_raw = 8 + (winner_score / 100.0) * 32
    elif winner_score_raw is not None:
        pct = int(round(((winner_score_raw - 8) / 32.0) * 100))
        winner_score = max(0, min(100, pct))
        winner_score_raw = 8 + (winner_score / 100.0) * 32
    if winner_score_breakdown is None:
        winner_score_breakdown = {}
    cur.execute(
        """
        INSERT INTO scores (
            product_id, model, total_score, momentum, saturation, differentiation,
            social_proof, margin, logistics, summary, explanations, created_at,
            winner_score_raw, winner_score, winner_score_breakdown)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, json(?), ?, ?, ?, json(?))
        """,
        (
            product_id,
            model,
            total_score,
            momentum,
            saturation,
            differentiation,
            social_proof,
            margin,
            logistics,
            summary,
            json_dump(explanations),
            created_at,
            winner_score_raw,
            winner_score,
            json_dump(winner_score_breakdown),
        ),
    )
    if commit:
        conn.commit()
    return cur.lastrowid

def remove_product_from_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Remove association of a product from a list (does not delete the product itself)."""
    cur = conn.cursor()
    cur.execute(
        "DELETE FROM list_items WHERE list_id = ? AND product_id = ?",
        (list_id, product_id),
    )
    conn.commit()


def get_scores_for_product(conn: sqlite3.Connection, product_id: int) -> List[sqlite3.Row]:
    """Retrieve all scores associated with a product."""
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM scores WHERE product_id = ? ORDER BY created_at DESC",
        (product_id,),
    )
    return cur.fetchall()


def create_list(conn: sqlite3.Connection, name: str) -> int:
    """Create a new list if it does not already exist."""
    cur = conn.cursor()
    try:
        cur.execute(
            "INSERT INTO lists (name) VALUES (?)",
            (name,),
        )
        conn.commit()
        return cur.lastrowid
    except sqlite3.IntegrityError:
        # List name already exists
        cur.execute("SELECT id FROM lists WHERE name = ?", (name,))
        row = cur.fetchone()
        return row["id"] if row else -1


def get_lists(conn: sqlite3.Connection) -> List[sqlite3.Row]:
    """Return all lists with product counts."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT l.id, l.name, COUNT(li.product_id) AS count
        FROM lists l
        LEFT JOIN list_items li ON li.list_id = l.id
        GROUP BY l.id
        ORDER BY l.name
        """
    )
    return cur.fetchall()


def add_product_to_list(conn: sqlite3.Connection, list_id: int, product_id: int) -> None:
    """Add a product to a list (idempotent)."""
    cur = conn.cursor()
    cur.execute(
        "INSERT OR IGNORE INTO list_items (list_id, product_id) VALUES (?, ?)",
        (list_id, product_id),
    )
    conn.commit()

def delete_list(
    conn: sqlite3.Connection,
    list_id: int,
    mode: str = "remove",
    target_list_id: int | None = None,
) -> dict:
    """Delete a list with options to detach or move products.

    Args:
        list_id: ID of the list to delete.
        mode: 'remove' to detach products or 'move' to reassign them.
        target_list_id: destination list ID when mode is 'move'.

    Returns:
        Dict summarising the action performed.
    """
    cur = conn.cursor()
    # Ensure list exists and fetch its name
    cur.execute("SELECT id, name FROM lists WHERE id = ?", (list_id,))
    row = cur.fetchone()
    if not row:
        raise ValueError("List not found")

    # Protected lists (by name)
    if row["name"].lower() in {"todos", "all"}:
        raise ValueError("Protected list")

    if mode == "move":
        if target_list_id is None:
            raise ValueError("target_list_id required for move")
        if target_list_id == list_id:
            raise ValueError("target_list_id must be different")
        # Ensure target exists
        cur.execute("SELECT id FROM lists WHERE id = ?", (target_list_id,))
        if not cur.fetchone():
            raise ValueError("Target list not found")
        # Get product ids in source
        cur.execute(
            "SELECT product_id FROM list_items WHERE list_id = ?", (list_id,)
        )
        products = [r[0] for r in cur.fetchall()]
        moved = 0
        for pid in products:
            cur.execute(
                "INSERT OR IGNORE INTO list_items (list_id, product_id) VALUES (?, ?)",
                (target_list_id, pid),
            )
            moved += cur.rowcount
        # Remove old associations and list
        cur.execute("DELETE FROM list_items WHERE list_id = ?", (list_id,))
        cur.execute("DELETE FROM lists WHERE id = ?", (list_id,))
        conn.commit()
        return {"deletedGroup": row["name"], "movedCount": moved}
    else:
        # Remove list; ON DELETE CASCADE cleans associations
        cur.execute(
            "SELECT COUNT(*) FROM list_items WHERE list_id = ?", (list_id,)
        )
        count = cur.fetchone()[0]
        cur.execute("DELETE FROM lists WHERE id = ?", (list_id,))
        conn.commit()
        return {"deletedGroup": row["name"], "detachedCount": count}


def get_products_in_list(conn: sqlite3.Connection, list_id: int) -> List[sqlite3.Row]:
    """Get all products in a particular list."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT p.* FROM products p
        JOIN list_items li ON li.product_id = p.id
        WHERE li.list_id = ?
        ORDER BY p.import_date DESC
        """,
        (list_id,),
    )
    return cur.fetchall()


def json_dump(obj: Any) -> str:
    """Utility to convert Python objects to JSON strings in a predictable way.

    SQLite ships with a JSON1 extension but doesn't include a serializer from Python
    dictionaries.  This helper uses the built‑in json module to dump objects.
    The ensure_ascii=False flag preserves unicode characters such as accents.
    """
    import json

    return json.dumps(obj or {}, ensure_ascii=False)


def find_product_by_name(conn: sqlite3.Connection, name: str) -> Optional[sqlite3.Row]:
    """
    Find a product by its name, case‑insensitively.  Returns the row if found or None.

    Args:
        conn: SQLite connection
        name: Product name to search

    Returns:
        A sqlite3.Row object for the first matching product, or None if not found.
    """
    cur = conn.cursor()
    cur.execute(
        "SELECT * FROM products WHERE LOWER(name) = LOWER(?) LIMIT 1",
        (name,),
    )
    return cur.fetchone()


def delete_product(conn: sqlite3.Connection, product_id: int) -> None:
    """
    Delete a product by its ID along with its associated scores and list entries.

    Args:
        conn: SQLite connection
        product_id: ID of the product to delete

    This function relies on foreign key ON DELETE CASCADE to remove scores and list
    associations automatically.
    """
    cur = conn.cursor()
    cur.execute("DELETE FROM products WHERE id = ?", (product_id,))
    conn.commit()


def create_import_job(
    conn: sqlite3.Connection,
    temp_path: Optional[str] = None,
    *,
    status: str = "pending",
    phase: str = "parse",
    total: int = 0,
    processed: int = 0,
    config: Optional[Dict[str, Any]] = None,
    budget_cents: Optional[int] = None,
) -> int:
    """Create a new pending import job and return its ID."""

    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        INSERT INTO import_jobs (
            status, phase, created_at, updated_at, total, processed,
            rows_imported, winner_score_updated, error, temp_path,
            config, budget_cents, metrics, ai_total, ai_done, ai_error, ai_counts, ai_pending
        )
        VALUES (?, ?, ?, ?, ?, ?, 0, 0, NULL, ?, json(?), ?, NULL, 0, 0, NULL, NULL, NULL)
        """,
        (
            status,
            phase,
            now,
            now,
            int(total or 0),
            int(processed or 0),
            temp_path,
            json_dump(config) if config is not None else None,
            budget_cents,
        ),
    )
    conn.commit()
    return cur.lastrowid


def complete_import_job(
    conn: sqlite3.Connection, job_id: int, rows: int, winner_score_updated: int = 0
) -> None:
    """Mark an import job as completed."""
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        UPDATE import_jobs
        SET status='done',
            phase='done',
            updated_at=?,
            rows_imported=?,
            processed=?,
            total=CASE WHEN total < ? THEN ? ELSE total END,
            winner_score_updated=?,
            error=NULL
        WHERE id=?
        """,
        (now, rows, rows, rows, rows, winner_score_updated, job_id),
    )
    conn.commit()


def fail_import_job(conn: sqlite3.Connection, job_id: int, error: str) -> None:
    """Mark an import job as failed."""
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        UPDATE import_jobs
        SET status='error', phase='done', updated_at=?, error=?
        WHERE id=?
        """,
        (now, error, job_id),
    )
    conn.commit()


def start_import_job_ai(conn: sqlite3.Connection, job_id: int, total: int) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        """
        UPDATE import_jobs
        SET status='ai', updated_at=?, ai_total=?, ai_done=0, ai_error=NULL
        WHERE id=?
        """,
        (now, total, job_id),
    )
    conn.commit()


def update_import_job_ai_progress(conn: sqlite3.Connection, job_id: int, done: int) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        "UPDATE import_jobs SET ai_done=?, updated_at=? WHERE id=?",
        (done, now, job_id),
    )
    conn.commit()


def set_import_job_ai_error(conn: sqlite3.Connection, job_id: int, error: str) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        "UPDATE import_jobs SET ai_error=?, updated_at=? WHERE id=?",
        (error, now, job_id),
    )
    conn.commit()


def set_import_job_ai_counts(
    conn: sqlite3.Connection, job_id: int, counts: Dict[str, Any], pending_ids: List[int]
) -> None:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        "UPDATE import_jobs SET ai_counts=?, ai_pending=?, updated_at=? WHERE id=?",
        (json.dumps(counts), json.dumps(pending_ids), now, job_id),
    )
    conn.commit()


def get_import_history(conn: sqlite3.Connection, limit: int = 20) -> List[sqlite3.Row]:
    """Return recent import jobs ordered by creation time."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT
            id AS task_id,
            status,
            phase,
            total,
            processed,
            rows_imported,
            winner_score_updated,
            created_at,
            updated_at,
            error,
            temp_path,
            config,
            budget_cents,
            metrics,
            ai_total,
            ai_done,
            ai_error,
            ai_counts,
            ai_pending
        FROM import_jobs
        ORDER BY created_at DESC
        LIMIT ?
        """,
        (limit,),
    )
    return cur.fetchall()


def get_import_job(conn: sqlite3.Connection, job_id: int) -> Optional[sqlite3.Row]:
    """Return a single import job by ID."""
    cur = conn.cursor()
    cur.execute(
        """
        SELECT
            id AS task_id,
            status,
            phase,
            total,
            processed,
            rows_imported,
            winner_score_updated,
            created_at,
            updated_at,
            error,
            temp_path,
            config,
            budget_cents,
            metrics,
            ai_total,
            ai_done,
            ai_error,
            ai_counts,
            ai_pending
        FROM import_jobs
        WHERE id=?
        """,
        (job_id,),
    )
    return cur.fetchone()


def update_import_job_progress(
    conn: sqlite3.Connection,
    job_id: int,
    *,
    phase: Optional[str] = None,
    status: Optional[str] = None,
    processed: Optional[int] = None,
    total: Optional[int] = None,
    rows_imported: Optional[int] = None,
    error: Optional[str] = None,
    metrics: Optional[Dict[str, Any]] = None,
    config: Optional[Dict[str, Any]] = None,
    commit: bool = True,
) -> None:
    """Update phase/progress information for an import job."""

    assignments = ["updated_at=?"]
    params: List[Any] = [datetime.utcnow().isoformat()]
    rows_value: Optional[int] = None
    if phase is not None:
        assignments.append("phase=?")
        params.append(phase)
    if status is not None:
        assignments.append("status=?")
        params.append(status)
    if processed is not None:
        assignments.append("processed=?")
        processed_val = int(processed)
        params.append(processed_val)
        rows_value = processed_val
    if total is not None:
        assignments.append("total=?")
        params.append(int(total))
    if rows_imported is not None:
        rows_value = int(rows_imported)

    if rows_value is not None:
        assignments.append("rows_imported=?")
        params.append(rows_value)
    if error is not None:
        assignments.append("error=?")
        params.append(error)
    if metrics is not None:
        assignments.append("metrics=json(?)")
        params.append(json_dump(metrics))
    if config is not None:
        assignments.append("config=json(?)")
        params.append(json_dump(config))

    if len(assignments) == 1:
        return

    params.append(job_id)
    sql = f"UPDATE import_jobs SET {', '.join(assignments)} WHERE id=?"
    cur = conn.cursor()
    cur.execute(sql, params)
    if commit:
        conn.commit()


def append_import_job_metrics(
    conn: sqlite3.Connection,
    job_id: int,
    batch_no: int,
    rows: int,
    duration_ms: float,
    throughput: float,
    *,
    commit: bool = False,
) -> None:
    cur = conn.cursor()
    cur.execute(
        """
        INSERT INTO import_job_metrics (job_id, batch_no, rows, duration_ms, throughput)
        VALUES (?, ?, ?, ?, ?)
        """,
        (job_id, batch_no, int(rows), float(duration_ms), float(throughput)),
    )
    if commit:
        conn.commit()


def get_recent_import_metrics(conn: sqlite3.Connection, limit: int = 50) -> List[sqlite3.Row]:
    cur = conn.cursor()
    cur.execute(
        """
        SELECT job_id, batch_no, rows, duration_ms, throughput, created_at
        FROM import_job_metrics
        ORDER BY id DESC
        LIMIT ?
        """,
        (limit,),
    )
    return cur.fetchall()


def transition_job_items(
    conn: sqlite3.Connection,
    job_id: int,
    from_state: str,
    to_state: str,
    *,
    commit: bool = False,
) -> int:
    now = datetime.utcnow().isoformat()
    cur = conn.cursor()
    cur.execute(
        "UPDATE items SET state=?, updated_at=? WHERE job_id=? AND state=?",
        (to_state, now, job_id, from_state),
    )
    if commit:
        conn.commit()
    return cur.rowcount


def merge_staging_into_products(conn: sqlite3.Connection, job_id: int) -> None:
    cur = conn.cursor()
    cur.execute(
        """
        INSERT INTO products (
            name, description, category, price, currency, image_url, source,
            import_date, desire, desire_magnitude, awareness_level,
            competition_level, date_range, winner_score, extra, sig_hash
        )
        SELECT
            name, description, category, price, currency, image_url, source,
            import_date, desire, desire_magnitude, awareness_level,
            competition_level, date_range, winner_score, extra, sig_hash
        FROM products_staging
        WHERE job_id=?
        ON CONFLICT(sig_hash) DO UPDATE SET
            name=excluded.name,
            description=excluded.description,
            category=excluded.category,
            price=excluded.price,
            currency=excluded.currency,
            image_url=excluded.image_url,
            source=excluded.source,
            import_date=excluded.import_date,
            desire=excluded.desire,
            desire_magnitude=excluded.desire_magnitude,
            awareness_level=excluded.awareness_level,
            competition_level=excluded.competition_level,
            date_range=excluded.date_range,
            winner_score=COALESCE(excluded.winner_score, products.winner_score),
            extra=excluded.extra
        """,
        (job_id,),
    )


def clear_staging_for_job(conn: sqlite3.Connection, job_id: int, *, commit: bool = False) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM products_staging WHERE job_id=?", (job_id,))
    if commit:
        conn.commit()

def mark_stale_pending_imports(conn: sqlite3.Connection, minutes: int) -> None:
    """Mark pending imports older than X minutes as errored after restart."""
    cutoff = (datetime.utcnow() - timedelta(minutes=minutes)).isoformat()
    cur = conn.cursor()
    cur.execute(
        "SELECT id, temp_path FROM import_jobs WHERE status='pending' AND created_at <= ?",
        (cutoff,),
    )
    rows = cur.fetchall()
    for row in rows:
        cur.execute(
            "UPDATE import_jobs SET status='error', updated_at=?, error='server restarted' WHERE id=?",
            (datetime.utcnow().isoformat(), row["id"]),
        )
        if row["temp_path"]:
            try:
                Path(row["temp_path"]).unlink()
            except Exception:
                pass
    conn.commit()