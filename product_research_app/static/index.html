<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Product Research Copilot</title>
<link rel="stylesheet" href="/static/css/app.css">
<link rel="stylesheet" href="/static/css/toast.css">
<link rel="stylesheet" href="/static/css/loading.css">
<script type="module" src="/static/js/config.js" defer></script>
<script type="module" src="/static/js/net.js" defer></script>
<script defer src="/static/js/legacy-progress-shim.js"></script>
<style>
/* Basic layout */
body { margin:0; padding:0; font-family: 'Segoe UI', Tahoma, sans-serif; color:#222; background: linear-gradient(to bottom, #f8fbff, #e9f0ff); }
body.dark { background: #1a1b2e; color:#eaeaea; }
#app-header .app-toolbar { padding:20px; text-align:center; background: linear-gradient(90deg, #0062ff, #00c8ff); color:#fff; box-shadow:0 2px 5px rgba(0,0,0,0.3); }
body.dark #app-header .app-toolbar { background: linear-gradient(90deg, #2e2e78, #6547a6); }
.container { max-width: 1200px; margin: 0 auto; padding: 10px; }
.card { background:#121426; border:1px solid #222642; border-radius:10px; padding:12px; margin-bottom:15px; }
body.dark .card { background:#121426; border-color:#222642; }
/* Controls */
#controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
button { padding:8px 14px; border:none; border-radius:4px; cursor:pointer; background: linear-gradient(90deg,#0062ff,#00c8ff); color:#fff; font-weight:600; box-shadow:0 3px 5px rgba(0,0,0,0.2); transition:opacity 0.2s; }
button:hover { opacity:0.85; }
body.dark button { background: linear-gradient(90deg,#3a3cad,#7a53d6); color:#fff; }
/* Chip style for filter toggle */
#btnFilters { background:#e0f0ff; border:1px solid #0077cc; color:#0077cc; padding:6px 10px; border-radius:16px; font-size:14px; }
body.dark #btnFilters { background:#2a2d5c; border-color:#7a53d6; color:#a9a9ff; }
select, input[type="text"], input[type="password"] { padding:6px; border-radius:4px; border:1px solid #ccc; }
body.dark select, body.dark input[type="text"], body.dark input[type="password"] { background:#1f2344; color:#eaeaea; border-color:#444; }
th, td { padding:8px; border:1px solid #ccc; }
body.dark th, body.dark td { border-color:#444; }
tbody tr:nth-child(even) { background:#f2f6ff; }
body.dark tbody tr:nth-child(even) { background:#2a2d5c; }
body.dark tbody tr:nth-child(odd) { background:#25285a; }
tbody tr:hover {
  box-shadow: 0 0 6px rgba(0,0,0,0.2);
  transform: translateY(-2px);
  transition: box-shadow 0.2s, transform 0.2s;
}
#importBanner { background:rgba(122,83,214,0.2); color:#7a53d6; border:1px solid rgba(122,83,214,0.3); }
body.dark #importBanner { background:rgba(122,83,214,0.2); color:#c9b9f3; border:1px solid rgba(122,83,214,0.4); }
/* History & Details */
#history details { margin-bottom:8px; }
details summary { cursor:pointer; font-weight:600; color:#0062ff; }
body.dark details summary { color:#80b3ff; }
pre { white-space:pre-wrap; background:#f5f7ff; padding:8px; border-radius:4px; }
body.dark pre { background:#2e315f; }
/* Weight slider styling */
.field-label { display:block; margin-top:10px; font-weight:600; }

#section-trends[hidden]{display:none;}
#trendHeader{display:flex;flex-wrap:wrap;gap:8px;align-items:flex-end;margin-bottom:16px;}
.kpi-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:20px;}
@media (max-width:600px){.kpi-grid{grid-template-columns:repeat(2,1fr);}}
.kpi{text-align:center;padding:8px;}
.kpi-value{font-size:1.2rem;font-weight:600;}
.kpi-label{font-size:0.8rem;opacity:0.8;}
.kpi-delta{font-size:0.8rem;}
.sparklines-row{display:flex;gap:10px;margin-bottom:20px;}
.sparklines-row canvas{flex:1;height:140px;}
.trend-main{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:20px;}
.trend-main .card{flex:1;min-width:280px;max-height:320px;overflow:auto;}
.chart-wrapper{position:relative;height:240px;}
.metric-selector{display:flex;gap:4px;margin-left:auto;}
.metric-btn{padding:4px 8px;font-size:12px;}
.metric-btn.active{opacity:0.7;}
.skeleton{background:#ddd;border-radius:4px;height:40px;animation:skeleton-pulse 1.2s infinite ease-in-out;}
body.dark .skeleton{background:#333;}
@keyframes skeleton-pulse{0%{opacity:0.7;}50%{opacity:0.4;}100%{opacity:0.7;}}

/* Oculta KPIs si a√∫n existen en el DOM */
.kpi-grid, .kpi, .kpis { display: none !important; }

/* Fila de gr√°ficos */
.trends-row {
  display: grid;
  grid-template-columns: 2fr 1.2fr;
  gap: 16px;
  margin-top: 8px;
}

/* Cards y lienzos */
#section-trends .card { background: var(--panel, #171a2b); border-radius: 10px; padding: 12px; }
#section-trends .card.lg { min-height: 380px; }
#section-trends .card.md { min-height: 380px; }
#section-trends .card-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
#topCategoriesChart, #priceIncomeScatter { width:100%; height:100%; }

/* Tabla compacta */
.table.compact th, .table.compact td { padding: 8px 10px; }
.table.compact th[role="button"] { cursor: pointer; user-select: none; }
.table.compact th.sort-asc::after  { content: " \25B2"; opacity: .7; }
.table.compact th.sort-desc::after { content: " \25BC"; opacity: .7; }

</style>
</head>
<body class="dark">
<header id="topBar" class="app-header topbar">
  <div id="app-header">
    <div class="app-toolbar" style="padding:8px 15px; display:flex; align-items:center; justify-content:space-between; position:relative;">
      <div style="display:flex; align-items:center; gap:8px;">
        <h1 style="margin:0; font-size:1.4rem;">Ecom Testing App</h1>
        <p style="margin:0;font-size:12px; opacity:0.8;">By El Tito ü§ô</p>
      </div>
      <div style="flex:1; display:flex; justify-content:flex-end; gap:8px; align-items:center;">
        <input type="file" id="fileInput" style="display:none;" />
        <button id="uploadBtn" title="Subir archivo">üì§</button>
        <button id="refreshBtn" title="Actualizar lista">üîÑ</button>
        <button id="btn-ver-tendencias" title="Ver tendencias" data-action="toggle-trends">üìä</button>
        <button id="darkToggle" title="Modo oscuro">üåô</button>
        <button id="configBtn" title="Configuraci√≥n avanzada">‚öôÔ∏è</button>
      </div>
    </div>
    <div id="global-progress" class="progress-host" hidden>
      <div class="progress-bar">
        <div id="progress-slot-global" class="progress-slot" aria-live="polite"></div>
        <span class="progress-label">Cargando‚Ä¶</span>
      </div>
      <button id="btn-cancel-import" class="btn-cancel" hidden title="Cancelar importaci√≥n">‚úï</button>
    </div>
  </div>
  <!-- Search bar row with controls -->
  <div id="searchRow">
    <input type="text" id="searchInput" placeholder="Buscar producto o palabra clave..." aria-label="Buscar productos" />
    <button id="searchBtn">Buscar</button>
    <button id="btnFilters">Filtros</button>
    <div id="activeFilterChips"></div>
    <input type="text" id="newListName" placeholder="Nombre del grupo" style="padding:4px; min-width:120px;">
    <button id="createListBtn">Crear</button>
    <textarea id="gptPrompt" rows="1" maxlength="2000" placeholder="Escribe consulta para GPT..." aria-label="Escribe consulta para GPT..."></textarea>
    <div id="gptActions">
      <button id="sendPrompt">Enviar consulta a GPT</button>
      <button id="btnGenWinner" class="bar-btn" disabled title="Generar Winner Score" aria-label="Generar Winner Score">Generar Winner Score</button>
    </div>
    <div id="searchRowRight">
      <div id="listMeta">0 resultados</div>
    </div>
  </div>
</header>
<div id="importBanner" style="display:none; padding:8px; text-align:center;"></div>
<div id="config" style="display:none;">
  <div class="config-controls">
    <label for="modelSelect">Modelo</label>
    <select id="modelSelect">
      <option value="gpt-4o">GPT-4o</option>
      <option value="gpt-4">GPT-4</option>
      <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
    </select>
    <button id="toggleApiKey" type="button" style="display:none;">Cambiar API Key</button>
  </div>
  <div class="api-row">
    <label for="apiKey">API Key</label>
    <div class="api-input-row">
      <input type="password" id="apiKey" />
      <button id="saveApiKey" disabled aria-label="Guardar API Key" title="Guardar API Key">Guardar API Key</button>
    </div>
  </div>
</div>
<div id="weightsCard" class="card" style="display:none;">
  <strong>Ponderaciones Winner Score</strong>
  <div class="legend">‚ÑπÔ∏è Arrastra para reordenar. M√°s arriba = mayor prioridad. El n√∫mero (0‚Äì100) es el peso.</div>
  <ul id="weightsList" class="weights-list"></ul>
</div>
<div id="weightsFooter" class="config-footer" style="display:none;">
  <button id="btnReset" class="btn">Reset</button>
  <button id="btnAiWeights" class="btn primary">Ajustar pesos con IA</button>
</div>
<div id="custom" style="display:none;">
  <div id="history" style="margin-top:10px;"></div>
</div>
<section id="section-trends" hidden>
  <div id="trendHeader">
    <label>Desde: <input type="text" id="fecha-desde"></label>
    <label>Hasta: <input type="text" id="fecha-hasta"></label>
    <button id="btn-aplicar-tendencias" aria-label="Aplicar filtros">Aplicar</button>
  </div>
  <div id="trends-status"></div>
  <section id="trends" class="trends-grid" hidden>
    <div class="card" id="top-left">
      <div class="chart-header">
        <h4>Top categor√≠as</h4>
        <button class="chart-help" aria-label="Ayuda gr√°fico top categor√≠as"
                data-tip="Barras: valor de la m√©trica seleccionada para cada categor√≠a (ordenadas de mayor a menor). Eje: escala lineal. Pasa el rat√≥n para ver el detalle.">
          i
        </button>
      </div>
      <div class="chart-wrap chart-wrap--sm">
        <canvas id="topCategoriesChart"></canvas>
      </div>
    </div>

    <div class="card" id="top-right">
      <div class="chart-header">
        <h4>Pareto de ingresos (Top 15)</h4>
        <button class="chart-help" aria-label="Ayuda gr√°fico pareto"
                data-tip="Barras: ingresos por categor√≠a (ordenadas desc). L√≠nea: % acumulado (eje derecho) que muestra qu√© porcentaje del total se alcanza al sumar desde la categor√≠a m√°s alta. Eje izquierdo: ‚Ç¨ ingresos. Eje derecho: porcentaje.">
          i
        </button>
      </div>
      <div class="chart-wrap">
        <canvas id="paretoRevenueChart"></canvas>
      </div>
    </div>
  </section>

  <section id="trends-bottom" class="two-col" hidden>
    <div class="card">
      <table id="trendsTable" class="table table--compact">
        <thead>
          <tr>
            <th data-key="path" data-type="text">Categor√≠as</th>
            <th data-key="products" data-type="num">Productos</th>
            <th data-key="units" data-type="num">Unidades</th>
            <th data-key="revenue" data-type="num">Ingresos</th>
            <th data-key="price" data-type="num">Precio</th>
            <th data-key="rating" data-type="num">Rating</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <aside class="card" id="trendsInsights">
      <div class="insights-toolbar">
        <button id="btnLocalInsights" class="btn btn--sm">Generar insights (local)</button>
      </div>
      <div id="insightsContent" class="insights-content">
        <p class="muted">Aqu√≠ aparecer√°n hallazgos relevantes sobre las categor√≠as (tendencias, outliers, pareto‚Ä¶).</p>
      </div>
    </aside>
  </section>
</section>

<section id="section-products">
  <div class="table-wrap">
    <table id="productTable" class="products-table">
      <colgroup>
        <col class="sel">
        <col class="id">
        <col class="imagen">
        <col class="nombre">
        <col class="categoria">
        <col class="price">
        <col class="rating">
        <col class="unidades">
        <col class="ingresos">
        <col class="conv">
        <col class="fecha">
        <col class="rango">
        <col class="desire">
        <col class="magnet">
        <col class="aware">
        <col class="comp">
        <col class="wscore">
        <col class="actions">
      </colgroup>
      <thead>
        <tr id="headerRow"></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <div id="bottomBar" class="bottombar hidden">
  <button id="legendBtn" class="legend-btn" title="Mostrar leyenda" aria-label="Mostrar leyenda">‚ÑπÔ∏è</button>
  <span id="selCount"></span>
  <select id="groupSelect" aria-label="Filtrar por grupo"></select>
  <button id="btnAddToGroup" class="bar-btn" disabled title="A√±adir seleccionados al grupo" aria-label="A√±adir seleccionados al grupo">A√±adir a grupo</button>
  <button id="btnManageGroups" class="bar-btn" title="Gestionar grupos" aria-label="Gestionar grupos">Gestionar grupos</button>
  <button id="btnDelete" class="bar-btn" disabled title="Eliminar seleccionados" aria-label="Eliminar seleccionados">Eliminar</button>
  <button id="btnExport" class="bar-btn" disabled title="Exportar seleccionados" aria-label="Exportar seleccionados">Exportar</button>
  <button id="btnColumns" class="bar-btn" title="Gestionar columnas" aria-label="Gestionar columnas">Columnas</button>
  </div>
  <div id="legendPop" class="popover hidden">
  <div>‚Ä¢ Fila roja: duplicado</div>
  <div>‚Ä¢ üî• x1‚Äìx5: tendencia en el nombre</div>
  </div>
  <div id="columnsPanel" class="popover hidden"></div>
</section>

<!-- Overlay for viewing images in larger size -->
<div id="imgOverlay" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.8); justify-content:center; align-items:center; z-index:1000;">
  <img id="overlayImg" src="" style="max-width:90%; max-height:90%; box-shadow:0 0 10px #000; border-radius:8px;" />
</div>
<div id="filtersDrawer" class="drawer right hidden">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <h3>Filtros</h3>
    <button id="closeFilters">√ó</button>
  </div>
  <div class="filters-grid">
    <!-- ID -->
    <label>ID</label>
    <input id="f-id" placeholder="e.g. 1,3-7">

    <!-- Categor√≠a -->
    <label>Categor√≠a</label>
    <input id="f-category" placeholder="contiene‚Ä¶">

    <!-- Price -->
    <label>Precio m√≠n</label>
    <input id="f-price-min" inputmode="decimal" placeholder="‚Ç¨">
    <label>Precio m√°x</label>
    <input id="f-price-max" inputmode="decimal" placeholder="‚Ç¨">

    <!-- Rating -->
    <label>Rating m√≠n</label>
    <input id="f-rating-min" inputmode="decimal" placeholder="0‚Äì5">
    <label>Rating m√°x</label>
    <input id="f-rating-max" inputmode="decimal" placeholder="0‚Äì5">

    <!-- Unidades vendidas -->
    <label>Unidades m√≠n</label>
    <input id="f-units-min" inputmode="numeric" placeholder="K/M ok">
    <label>Unidades m√°x</label>
    <input id="f-units-max" inputmode="numeric" placeholder="K/M ok">

    <!-- Ingresos -->
    <label>Ingresos m√≠n</label>
    <input id="f-revenue-min" inputmode="decimal" placeholder="‚Ç¨ K/M ok">
    <label>Ingresos m√°x</label>
    <input id="f-revenue-max" inputmode="decimal" placeholder="‚Ç¨ K/M ok">

    <!-- Tasa de conversi√≥n -->
    <label>Conv. m√≠n</label>
    <input id="f-conv-min" inputmode="decimal" placeholder="%">
    <label>Conv. m√°x</label>
    <input id="f-conv-max" inputmode="decimal" placeholder="%">

    <!-- Fecha lanzamiento -->
    <label>Fecha desde</label>
    <input id="f-date-from" type="date">
    <label>Fecha hasta</label>
    <input id="f-date-to" type="date">

    <!-- Rango Fechas (columna texto) -->
    <label>Rango Fechas</label>
    <input id="f-range-text" placeholder="contiene‚Ä¶">

    <!-- Desire magnitude -->
    <label>Desire magnitude</label>
    <select id="f-desire-mag">
      <option value="">Cualquiera</option>
      <option>Low</option><option>Medium</option><option>High</option>
    </select>

    <!-- Awareness level -->
    <label>Awareness level</label>
    <select id="f-awareness">
      <option value="">Cualquiera</option>
      <option value="unaware">Unaware</option>
      <option value="problemaware">Problem-Aware</option>
      <option value="solutionaware">Solution-Aware</option>
      <option value="productaware">Product-Aware</option>
      <option value="mostaware">Most Aware</option>
    </select>

    <!-- Competition level -->
    <label>Competition level</label>
    <select id="f-competition">
      <option value="">Cualquiera</option>
      <option>Low</option><option>Medium</option><option>High</option>
    </select>

    <!-- Winner Score -->
    <label>Winner Score m√≠n</label>
    <input id="f-score-min" inputmode="numeric" placeholder="0‚Äì100">
    <label>Winner Score m√°x</label>
    <input id="f-score-max" inputmode="numeric" placeholder="0‚Äì100">
  </div>
  <div style="display:flex; gap:8px; margin-top:12px;">
    <button id="applyFilters" style="flex:1;">Aplicar</button>
    <button id="clearFilters" style="flex:1;">Limpiar</button>
  </div>
</div>
<script type="module" src="/static/js/loading.js" defer></script>
<script src="/static/js/overlay.js" defer></script>
<script src="/static/js/toast.js" defer></script>
<script src="/static/js/table.js" defer></script>
<script src="/static/js/columns.js" defer></script>
<script type="module" src="/static/js/add-group.js" defer></script>
<script type="module" src="/static/js/manage-groups.js" defer></script>
<script src="/static/js/winner_score.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" defer></script>
<script type="module" src="/static/js/trends-summary.js" defer></script>
<script type="module" src="/static/js/trends-insights.js" defer></script>
<script type="module" src="/static/js/table-sort.js" defer></script>
<script type="module" src="/static/js/help-tooltip.js" defer></script>
<script type="module" defer>
import { applyFilters, readFilters } from '/static/js/filters-panel.js';
import * as api from "/static/js/net.js";
import * as groupsService from "/static/js/groups-service.js";
import { LoadingHelpers } from '/static/js/loading.js';
const { fetchJson } = api;
const metricKeys = window.metricKeys;
const openConfigModal = window.openConfigModal;
const saveIfDirty = window.saveIfDirty;
window.fetchJson = fetchJson;
window.groupsService = groupsService;
const IMPORT_TASK_LS_KEY = 'last_import_task';
const IMPORT_UPLOAD_FRAC = 0.30;
const IMPORT_POLL_MAX_FRAC = 0.99;
const IMPORT_SERVER_SPAN = IMPORT_POLL_MAX_FRAC - IMPORT_UPLOAD_FRAC;
const IMPORT_STATUS_URL = '/_import_status';
const IMPORT_START_URL = '/upload';
let savedApiKeyHash = null;
let savedApiKeyLength = 0;

const getGlobalProgressHost = () => document.querySelector('#progress-slot-global');
const getActionHost = () => document.querySelector('#bottomBar') || getGlobalProgressHost();

const getProgressBar = () => document.querySelector('#global-progress .progress-bar');
const getProgressLabel = () => document.querySelector('#global-progress .progress-label');
const cancelBtn = document.getElementById('btn-cancel-import');

function showCancel(visible) {
  if (!cancelBtn) return;
  cancelBtn.hidden = !visible;
  if (!visible) {
    cancelBtn.disabled = false;
  }
}

function markCancelled() {
  const bar = getProgressBar();
  const label = getProgressLabel();
  bar?.classList.add('is-cancelled');
  if (label) label.textContent = 'Cancelado';
}

let importPollController = null;
let importPollingCancelled = false;

function stopImportPolling() {
  importPollingCancelled = true;
  if (importPollController) {
    try { importPollController.abort(); }
    catch (e) {}
  }
}

window.stopImportPolling = stopImportPolling;

async function cancelImport() {
  if (!cancelBtn || !window.currentTaskId) return;
  cancelBtn.disabled = true;
  try {
    await fetch('/_import_cancel', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ task_id: window.currentTaskId })
    });
  } catch (e) {}
  stopImportPolling();
  markCancelled();
  showCancel(false);
  cancelBtn.disabled = false;
}

cancelBtn?.addEventListener('click', cancelImport);

window.onImportStart = function(taskId) {
  const bar = getProgressBar();
  const label = getProgressLabel();
  bar?.classList.remove('is-cancelled');
  if (label) label.textContent = 'Importando‚Ä¶';
  window.currentTaskId = taskId ? String(taskId) : '';
  importPollingCancelled = false;
  showCancel(Boolean(taskId));
};

window.onImportEnd = function() {
  window.currentTaskId = '';
  showCancel(false);
  const bar = getProgressBar();
  const label = getProgressLabel();
  bar?.classList.remove('is-cancelled');
  if (label) label.textContent = 'Listo';
  if (cancelBtn) cancelBtn.disabled = false;
};

(function stickyOffsets(){
  const root = document.documentElement;
  const px = (n) => `${n || 0}px`;
  function update(){
    const topbar = document.querySelector('.topbar');
    const progress = document.querySelector('#global-progress');
    root.style.setProperty('--topbar-h', px(topbar?.offsetHeight || 0));
    const progressVisible = progress && progress.offsetParent !== null && !progress.hidden;
    root.style.setProperty('--progress-h', px(progressVisible ? progress.offsetHeight : 0));
  }
  window.addEventListener('resize', update);
  new MutationObserver(update).observe(document.body, { subtree: true, attributes: true, attributeFilter: ['style','class','hidden'] });
  requestAnimationFrame(update);
})();

function formatPrice(n) {
  const num = Number(n);
  return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 })
    .format(Number.isFinite(num) ? num : 0);
}

function showImportBanner(msg) {
  const b = document.getElementById('importBanner');
  if (!b) return;
  b.textContent = msg;
  b.style.display = 'block';
}

function hideImportBanner() {
  const b = document.getElementById('importBanner');
  if (b) b.style.display = 'none';
}

async function sha256(str) {
  const buf = new TextEncoder().encode(str);
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  return Array.from(new Uint8Array(hashBuf))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

function mapServerFraction(serverPct) {
  const clamped = Math.max(0, Math.min(100, Number(serverPct) || 0));
  const frac = IMPORT_UPLOAD_FRAC + (clamped / 100) * IMPORT_SERVER_SPAN;
  return Math.min(IMPORT_POLL_MAX_FRAC, frac);
}

async function followImportTask(taskId, tracker, { statusUrl = IMPORT_STATUS_URL, host = getGlobalProgressHost() } = {}) {
  const id = typeof taskId === 'string' ? taskId : String(taskId || '');
  if (!id) return null;
  const controller = new AbortController();
  importPollController = controller;
  importPollingCancelled = false;

  const makeCancelledError = () => {
    const err = new Error('Importaci√≥n cancelada');
    err.name = 'ImportCancelledError';
    err.isCancelled = true;
    return err;
  };

  try {
    while (true) {
      if (importPollingCancelled) {
        throw makeCancelledError();
      }
      let data;
      try {
        const resp = await fetch(`${statusUrl}?task_id=${encodeURIComponent(id)}&t=${Date.now()}`,
          { __skipLoadingHook: true, __hostEl: host, cache: 'no-store', signal: controller.signal }
        );
        if (!resp.ok) throw new Error('Estado no disponible');
        data = await resp.json();
      } catch (err) {
        if (controller.signal.aborted || importPollingCancelled) {
          throw makeCancelledError();
        }
        await sleep(900);
        continue;
      }
      if (data.ui_cost_message) showImportBanner(data.ui_cost_message);
      const raw = data.pct ?? data.percent ?? data.percentage ?? data.progress ?? (data.done ? 100 : undefined);
      let serverPct = Number(raw);
      if (!Number.isFinite(serverPct)) serverPct = 0;
      serverPct = Math.max(0, Math.min(100, serverPct));
      const stage = (data.message || data.stage || data.state || '').toString() || 'Procesando‚Ä¶';
      tracker?.step(mapServerFraction(serverPct), stage);

      const statusVal = String(data.state || data.status || '').toLowerCase();
      if (statusVal === 'error' || data.error) {
        throw new Error(data.error || 'Error en importaci√≥n');
      }
      if (statusVal === 'unknown' || !statusVal) {
        throw new Error('Estado de importaci√≥n desconocido');
      }
      if (statusVal === 'cancelled' || statusVal === 'canceled' || data.cancelled) {
        markCancelled();
        showCancel(false);
        throw makeCancelledError();
      }
      if (serverPct >= 100 || statusVal === 'done' || statusVal === 'completed' || statusVal === 'finished') {
        await reloadTable({ skipProgress: true });
        hideImportBanner();
        return data;
      }
      await sleep(450);
    }
  } finally {
    if (importPollController === controller) {
      importPollController = null;
    }
    importPollingCancelled = false;
    if (!controller.signal.aborted) {
      try { controller.abort(); }
      catch (e) {}
    }
  }
}

async function importCatalog(file, { startUrl = IMPORT_START_URL, statusUrl = IMPORT_STATUS_URL } = {}) {
  if (!file) throw new Error('Archivo no v√°lido');
  const host = getGlobalProgressHost();
  const tracker = LoadingHelpers.start('Importando cat√°logo', { host });
  tracker.setStage('Subiendo archivo‚Ä¶');
  let lastResult = null;
  try {
    const fd = new FormData();
    fd.append('file', file);
    const xhr = new XMLHttpRequest();
    xhr.responseType = 'json';
    xhr.__skipLoadingHook = true;
    xhr.__hostEl = host;
    const startResult = await new Promise((resolve, reject) => {
      xhr.open('POST', startUrl, true);
      xhr.upload.onprogress = (event) => {
        if (!event.lengthComputable) return;
        const frac = Math.min(IMPORT_UPLOAD_FRAC, (event.loaded / event.total) * IMPORT_UPLOAD_FRAC);
        tracker.step(frac, 'Subiendo archivo‚Ä¶');
      };
      xhr.onerror = () => reject(new Error('Error de red subiendo archivo'));
      xhr.onload = () => {
        let payload = xhr.response;
        if (!payload && xhr.responseText) {
          try { payload = JSON.parse(xhr.responseText); }
          catch (e) { payload = null; }
        }
        const ok = xhr.status >= 200 && xhr.status < 300;
        if (!ok || !payload) {
          const message = payload?.error || payload?.message || 'Respuesta inv√°lida al iniciar importaci√≥n';
          reject(new Error(message));
          return;
        }
        if (payload.task_id) {
          resolve({ kind: 'async', taskId: payload.task_id, data: payload });
          return;
        }
        resolve({ kind: 'sync', data: payload });
      };
      xhr.send(fd);
    });

    if (startResult.kind === 'sync') {
      tracker.step(1, 'Completado');
      await reloadTable({ skipProgress: true });
      const importedCount = startResult.data?.imported ?? startResult.data?.rows_imported;
      if (Number.isFinite(importedCount) && importedCount > 0) {
        toast.success(`Importados ${importedCount}`);
      }
      return startResult.data;
    }

    const taskId = startResult.taskId;
    const idStr = typeof taskId === 'string' ? taskId : String(taskId);
    window.onImportStart?.(idStr);
    tracker.step(IMPORT_UPLOAD_FRAC, 'Archivo subido');
    localStorage.setItem(IMPORT_TASK_LS_KEY, idStr);

    lastResult = await followImportTask(idStr, tracker, { statusUrl, host });

    const importedCount = lastResult?.imported ?? lastResult?.rows_imported;
    if (Number.isFinite(importedCount) && importedCount > 0) {
      toast.success(`Importados ${importedCount}`);
    }
    tracker.step(1, 'Completado');
    return lastResult;
  } catch (err) {
    if (err?.name === 'ImportCancelledError' || err?.isCancelled) {
      tracker.step(1, 'Cancelado');
      markCancelled();
      return null;
    }
    tracker.step(1, 'Error');
    toast.error(err?.message || 'Error al importar cat√°logo');
    throw err;
  } finally {
    tracker.done();
    localStorage.removeItem(IMPORT_TASK_LS_KEY);
    hideImportBanner();
    window.onImportEnd?.();
  }
}

// Ensure the server shuts down cleanly when the tab or window is closed.
// Using fetch with `keepalive` guarantees the request completes even during unload.
window.addEventListener('beforeunload', () => {
  try {
    // Use fetch() instead of sendBeacon() because some browsers
    // drop beacon requests when no payload is provided. The `keepalive`
    // option allows the request to continue in the background while
    // the page is unloading.
    fetch('/shutdown', { method: 'POST', keepalive: true });
  } catch (err) {
    // As a fallback, attempt a minimal beacon with an empty payload.
    try { navigator.sendBeacon('/shutdown', ''); } catch (e) {}
  }
});
// Global arrays to hold all products and the current filtered list
let allProducts = [];
let products = [];
let sortField = null;
let sortDir = 1;
let sortType = 'string';

function ensureAppState(){
  window.appState = window.appState || {};
  return window.appState;
}

function getActiveFilters(){
  const state = ensureAppState();
  if (state.filters) return state.filters;
  const filters = readFilters();
  state.filters = filters;
  return filters;
}
function updateResultsBadge(total) {
  const meta = document.getElementById('listMeta');
  if (!meta) return;
  const count = typeof total === 'number' ? total : (Array.isArray(products) ? products.length : 0);
  meta.textContent = `${count} resultados`;
}

window.updateResultsBadge = updateResultsBadge;
window.allProducts = allProducts;
window.products = products;
const gridRoot = document.getElementById('productTable');

document.addEventListener('filters-changed', (e) => {
  if (e && e.detail) ensureAppState().filters = e.detail;
  selection.clear();
  renderTable();
});

function ecMakeMeasurer() {
  const el = document.createElement('span');
  el.id = 'ec-measure';
  el.style.position = 'absolute';
  el.style.visibility = 'hidden';
  el.style.height = 'auto';
  el.style.width = 'auto';
  el.style.whiteSpace = 'pre';
  el.style.font = 'inherit';
  el.style.letterSpacing = 'inherit';
  document.body.appendChild(el);
  return el;
}
const __ecMeasure = ecMakeMeasurer();

function ecTextPxWidth(text, sampleEl) {
  __ecMeasure.style.font = getComputedStyle(sampleEl).font;
  __ecMeasure.textContent = text || '';
  return __ecMeasure.offsetWidth;
}

const EC_LIMITS = {
  desire:         { min: 120, max: 320, pad: 24 },
  desire_mag:     { min:  90, max: 160, pad: 20 },
  awareness:      { min: 140, max: 220, pad: 20 },
  competition:    { min: 100, max: 160, pad: 20 },
};

function ecClamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function ecAutoFitColumns(gridRoot) {
  const desired = { desire: EC_LIMITS.desire.min, desire_mag: EC_LIMITS.desire_mag.min,
                    awareness: EC_LIMITS.awareness.min, competition: EC_LIMITS.competition.min };

  const rows = gridRoot.querySelectorAll('tr');
  rows.forEach(tr => {
    const tdDesire   = tr.querySelector('td.ec-col-desire input');
    const tdMag      = tr.querySelector('td.ec-col-desire-mag select');
    const tdAware    = tr.querySelector('td.ec-col-awareness select');
    const tdComp     = tr.querySelector('td.ec-col-competition select');

    if (tdDesire) {
      const txt = tdDesire.value || tdDesire.placeholder || '';
      const w = ecTextPxWidth(txt, tdDesire) + EC_LIMITS.desire.pad;
      desired.desire = Math.max(desired.desire, w);
    }
    if (tdMag) {
      const lbl = tdMag.options[tdMag.selectedIndex]?.text || '‚Äî';
      const w = ecTextPxWidth(lbl, tdMag) + EC_LIMITS.desire_mag.pad;
      desired.desire_mag = Math.max(desired.desire_mag, w);
    }
    if (tdAware) {
      const lbl = tdAware.options[tdAware.selectedIndex]?.text || '‚Äî';
      const w = ecTextPxWidth(lbl, tdAware) + EC_LIMITS.awareness.pad;
      desired.awareness = Math.max(desired.awareness, w);
    }
    if (tdComp) {
      const lbl = tdComp.options[tdComp.selectedIndex]?.text || '‚Äî';
      const w = ecTextPxWidth(lbl, tdComp) + EC_LIMITS.competition.pad;
      desired.competition = Math.max(desired.competition, w);
    }
  });

  const d  = ecClamp(desired.desire,       EC_LIMITS.desire.min,      EC_LIMITS.desire.max);
  const dm = ecClamp(desired.desire_mag,   EC_LIMITS.desire_mag.min,  EC_LIMITS.desire_mag.max);
  const aw = ecClamp(desired.awareness,    EC_LIMITS.awareness.min,   EC_LIMITS.awareness.max);
  const co = ecClamp(desired.competition,  EC_LIMITS.competition.min, EC_LIMITS.competition.max);

  gridRoot.style.setProperty('--ec-w-desire',        d  + 'px');
  gridRoot.style.setProperty('--ec-w-desire-mag',    dm + 'px');
  gridRoot.style.setProperty('--ec-w-awareness',     aw + 'px');
  gridRoot.style.setProperty('--ec-w-competition',   co + 'px');

  gridRoot.querySelectorAll('td.ec-col-desire-mag select').forEach(el => el.style.width = (dm - EC_LIMITS.desire_mag.pad) + 'px');
  gridRoot.querySelectorAll('td.ec-col-awareness select').forEach(el => el.style.width = (aw - EC_LIMITS.awareness.pad) + 'px');
  gridRoot.querySelectorAll('td.ec-col-competition select').forEach(el => el.style.width = (co - EC_LIMITS.competition.pad) + 'px');
}
const columns = [
  { key: 'id', label: 'ID', type: 'number', align: 'center' },
  { key: 'image_url', label: 'Imagen', type: 'image', align: 'center' },
  { key: 'name', label: 'Nombre', type: 'string' },
  { key: 'category', label: 'Categor√≠a', type: 'string' },
  { key: 'price', label: 'Price', type: 'number', align: 'right', editable: false,
    headerClass:'price-col', cellClass:'price-col',
    render: row => new Intl.NumberFormat('en-US', { style:'currency', currency:'USD', maximumFractionDigits: 2 }).format(row.price ?? 0) },
  { key: 'Product Rating', label: 'Rating', type: 'number', align: 'center' },
  { key: 'Item Sold', label: 'Unidades Vendidas', type: 'number', align: 'right' },
  { key: 'Revenue($)', label: 'Ingresos', type: 'number', align: 'right' },
  { key: 'Creator Conversion Ratio', label: 'Tasa Conversi√≥n', type: 'string', align: 'right' },
  { key: 'Launch Date', label: 'Fecha Lanzamiento', type: 'string' },
  { key: 'date_range', label: 'Rango Fechas', type: 'string', headerClass: 'cell-date-range', cellClass: 'cell-date-range' },
  { key: 'desire', label: 'Desire', type: 'string', headerClass: 'ec-col ec-col-desire col-desire', cellClass: 'ec-col ec-col-desire col-desire', dataEcCol: 'desire' },
  { key: 'desire_magnitude', label: 'Desire magnetitude', type: 'string', headerClass: 'ec-col ec-col-desire-mag', cellClass: 'ec-col ec-col-desire-mag', dataEcCol: 'desire_magnitude' },
  { key: 'awareness_level', label: 'Awerness Level', type: 'string', headerClass: 'ec-col ec-col-awareness', cellClass: 'ec-col ec-col-awareness', dataEcCol: 'awareness_level' },
  { key: 'competition_level', label: 'Competition level', type: 'string', headerClass: 'ec-col ec-col-competition', cellClass: 'ec-col ec-col-competition', dataEcCol: 'competition_level' },
  { key: 'winner_score', label: 'Winner Score', type: 'number', align: 'right' },
];

const rightAlignedKeys = new Set(['price', 'Item Sold', 'Revenue($)', 'Creator Conversion Ratio', 'winner_score']);
const centerAlignedKeys = new Set(['id', 'image_url', 'Product Rating']);

let trendingWords = [];

function mapTrendingScore(raw){
  const n = Number(raw);
  if (isNaN(n)) return 0;
  if (n <= 5) return Math.max(0, Math.round(n));
  if (n <= 9) return 0;
  if (n <= 19) return 1;
  if (n <= 34) return 2;
  if (n <= 54) return 3;
  if (n <= 79) return 4;
  return 5;
}

function normalizeDupKey(item){
  const norm = (str) => (str || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
    .replace(/\s+/g, ' ');
  return norm(item.name) + '|' + norm(item.image_url);
}

function preprocessProducts(list){
  const dupMap = new Map();
  list.forEach(item => {
    item.trending = mapTrendingScore(item.trendingScore);
    const desireSources = [
      item.desire,
      item.extras && item.extras.desire,
      item.ai_desire,
      item.ai_desire_label,
      item.desire_magnitude
    ];
    let desireVal = '';
    for (const src of desireSources) {
      if (src !== undefined && src !== null && String(src).trim() !== '') {
        desireVal = String(src);
        break;
      }
    }
    item.desire = desireVal;
    if (item.extras && item.extras['duplicate_of']) {
      item.isDuplicate = true;
      return;
    }
    const key = normalizeDupKey(item);
    item._dupKey = key;
    const arr = dupMap.get(key);
    if (arr) arr.push(item); else dupMap.set(key, [item]);
  });
  dupMap.forEach(arr => { if (arr.length > 1) arr.forEach(it => it.isDuplicate = true); });
}

function computeOldnessDays(p){
  const dr = p.date_range || p['Date Range'];
  let start=null;
  if(typeof dr==='string'){
    const m=dr.match(/(\d{4}-\d{2}-\d{2})\s*~\s*(\d{4}-\d{2}-\d{2})/);
    if(m) start=new Date(m[1]);
  }
  if(!start){
    const keys=['first_seen','created_at','createdAt'];
    for(const k of keys){
      const v=p[k];
      if(v){ try{ start=new Date(String(v).slice(0,10)); break; }catch(e){} }
    }
  }
  if(!start) return 0;
  const today=new Date();
  const diff=Math.floor((today-start)/(1000*60*60*24));
  return diff>0?diff:0;
}

async function loadConfig() {
  let cfg = {};
  try {
    cfg = await fetchJson('/config');
  } catch (err) {
    console.error('Error loading config', err);
  }
  if (cfg.model) {
    document.getElementById('modelSelect').value = cfg.model;
  }
  const input = document.getElementById('apiKey');
  const saveBtn = document.getElementById('saveApiKey');
  if (cfg.has_api_key) {
    savedApiKeyHash = cfg.api_key_hash || null;
    savedApiKeyLength = cfg.api_key_length || 0;
    const masked = '‚Ä¢'.repeat(Math.max(savedApiKeyLength - 4, 0)) + (cfg.api_key_last4 || '');
    if (input) input.value = masked;
    if (saveBtn) saveBtn.disabled = true;
    const row = document.querySelector('#config .api-row');
    if (row) row.style.display = 'none';
    document.getElementById('toggleApiKey').style.display = 'inline-flex';
  } else {
    savedApiKeyHash = null;
    savedApiKeyLength = 0;
    if (input) input.value = '';
    if (saveBtn) saveBtn.disabled = true;
  }
}

// helper to highlight trending keywords
function isTrending(name) {
  if (!name) return false;
  const words = name.toLowerCase().split(/[^a-z0-9√°√©√≠√≥√∫√º√±]+/);
  return words.some(w => trendingWords.includes(w));
}

async function fetchProducts(options = {}) {
  const prevSel = new Set(selection);
  const fetchOpts = options && options.skipProgress ? { __skipLoadingHook: true } : undefined;
  const data = await fetchJson('/products', fetchOpts);
  if(data.length && data[0].desire !== undefined && window.ensureColumnVisible){
    ensureColumnVisible('desire');
  }
  allProducts = data;
  preprocessProducts(allProducts);
  allProducts.sort((a,b)=> (Number(a.id)||0) - (Number(b.id)||0));
  sortField = 'id';
  sortDir = 1;
  sortType = 'number';
  window.allProducts = allProducts;
  renderTable();
  const visibleIds = new Set(products.map(p => String(p.id)));
  selection.clear();
  for (const id of prevSel) {
    if (visibleIds.has(id)) selection.add(id);
  }
  updateMasterState();
  renderTable();
}

window.fetchProducts = fetchProducts;
async function reloadTable(options){ await fetchProducts(options); }
async function reloadRows(ids, options){ await fetchProducts(options); }

function renderTable() {
  const headerRow = document.getElementById('headerRow');
  const tbody = document.querySelector('#productTable tbody');
  const baseList = Array.isArray(allProducts) ? allProducts : [];
  const filters = getActiveFilters();
  const filtered = applyFilters(baseList, filters);
  products = Array.isArray(filtered) ? [...filtered] : [];
  sortProducts();
  window.products = products;
  // Build header if empty
  if (!headerRow.hasChildNodes()) {
    // Add select column header (no label)
    const thSel = document.createElement('th');
    const selectAll = document.createElement('input');
    selectAll.type = 'checkbox';
    selectAll.id = 'selectAll';
    thSel.appendChild(selectAll);
    thSel.classList.add('center');
    headerRow.appendChild(thSel);
    // Add dynamic columns
    columns.forEach(col => {
      const th = document.createElement('th');
      th.textContent = col.label;
      th.style.cursor = 'pointer';
      th.setAttribute('data-key', col.key);
      if (col.headerClass) {
        col.headerClass.split(/\s+/).forEach(cls => { if (cls) th.classList.add(cls); });
      }
      if (col.dataEcCol) th.setAttribute('data-ec-col', col.dataEcCol);
      if (col.width) th.style.width = col.width + 'px';
      if (col.minWidth) th.style.minWidth = col.minWidth + 'px';
      if (col.maxWidth) th.style.maxWidth = col.maxWidth + 'px';
      if (col.align) th.style.textAlign = col.align;
      if (rightAlignedKeys.has(col.key)) th.classList.add('num');
      if (centerAlignedKeys.has(col.key)) th.classList.add('center');
      if (col.key === 'winner_score') th.title = 'Suma ponderada de 10 m√©tricas normalizadas';
      th.onclick = () => sortBy(col.key, col.type);
      headerRow.appendChild(th);
    });
    // Add delete column header
    const thDel = document.createElement('th');
    headerRow.appendChild(thDel);
  }
  // Clear body
  tbody.innerHTML = '';
  const visibleProducts = Array.isArray(products) ? [...products] : [];
  window.__visibleProducts = visibleProducts;
  window.__allProducts = baseList && baseList.length ? baseList : visibleProducts;
  document.dispatchEvent(new CustomEvent('visible-products-changed', {
    detail: { count: visibleProducts.length }
  }));
  // Render rows
  products.forEach(item => {
    const tr = document.createElement('tr');
    if (item.isDuplicate) {
      tr.classList.add('is-duplicate');
    }
    // Selection checkbox
    const tdSel = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.classList.add('rowCheck');
    const rowId = String(item.id);
    cb.dataset.id = rowId;
    cb.checked = selection.has(rowId);
    tr.classList.toggle('selected', cb.checked);
    cb.addEventListener('change', () => {
      const id = cb.dataset.id;
      if (cb.checked) selection.add(id); else selection.delete(id);
      tr.classList.toggle('selected', cb.checked);
      updateMasterState();
    });
    tdSel.appendChild(cb);
    tdSel.classList.add('center');
    tr.appendChild(tdSel);
    columns.forEach(col => {
      const td = document.createElement('td');
      const key = col.key;
      td.setAttribute('data-key', key);
      if (col.cellClass) {
        col.cellClass.split(/\s+/).forEach(cls => { if (cls) td.classList.add(cls); });
      }
      if (col.dataEcCol) td.setAttribute('data-ec-col', col.dataEcCol);
      if (col.width) td.style.width = col.width + 'px';
      if (col.minWidth) td.style.minWidth = col.minWidth + 'px';
      if (col.maxWidth) td.style.maxWidth = col.maxWidth + 'px';
      if (col.align) td.style.textAlign = col.align;
      if (rightAlignedKeys.has(key)) td.classList.add('num');
      if (centerAlignedKeys.has(key)) td.classList.add('center');
      let value = '';
      if (key === 'desire') {
        // La columna textual "Desire" NUNCA debe tratarse como m√©trica
        value = typeof item.desire === 'string' ? item.desire.trim() : (item.desire ?? '');
      } else if (metricKeys.includes(key)) {
        value = item.winner_score_breakdown && item.winner_score_breakdown.scores ? item.winner_score_breakdown.scores[key] : '';
        if (item.winner_score_breakdown && item.winner_score_breakdown.justifications) {
          const j = item.winner_score_breakdown.justifications[key];
          if (j) td.title = 'Justificaci√≥n: ' + j;
        }
      } else if (key === 'desire_magnitude') {
        value = item.desire_magnitude;
      } else if (['id','name','category','price','image_url','winner_score','awareness_level','competition_level','date_range'].includes(key)) {
        value = item[key];
      } else {
        value = item.extras ? item.extras[key] : '';
      }
      if (col.render) {
        try { td.textContent = col.render(item); } catch (e) { td.textContent = ''; }
      } else if (key === 'winner_score') {
        const sc = parseFloat(value);
        if (!isNaN(sc)) {
          const scInt = Math.round(sc);
          td.innerHTML = '<span class="' + winnerScoreClass(scInt) + '">' + scInt.toLocaleString(undefined,{maximumFractionDigits:0}) + '</span>';
          if (item.winner_score_breakdown && item.winner_score_breakdown.justifications) {
            const j = item.winner_score_breakdown.justifications;
            const tooltip = Object.entries(j).map(([k,v])=>`${k}: ${v}`).join('\n');
            td.title = tooltip;
          }
        }
      } else if (key === 'image_url' && value) {
        const img = document.createElement('img');
        img.src = value;
        img.loading = 'lazy';
        img.style.width = '84px';
        img.style.height = '84px';
        img.style.objectFit = 'cover';
        // Show larger image on click
        img.style.cursor = 'pointer';
        img.onclick = () => {
          showOverlay(value);
        };
        td.appendChild(img);
      } else if (key === 'name' && value) {
        const fireCount = item.trending || 0;
        const fireText = firesFor(fireCount);
        const nameSpan = document.createElement('span');
        nameSpan.textContent = value + (fireText ? ' ' : '');
        td.appendChild(nameSpan);
        if (fireCount > 0) {
          const fireSpan = document.createElement('span');
          fireSpan.className = 'fires';
          fireSpan.textContent = fireText;
          fireSpan.setAttribute('aria-label', `Tendencia: x${fireCount}`);
          fireSpan.title = `Tendencia: x${fireCount}`;
          td.appendChild(fireSpan);
        }
        // If Kalodata URL exists, add copy link button
        const kal = item.extras && item.extras['KalodataUrl'];
        if (kal) {
          const btnCopy = document.createElement('button');
          btnCopy.textContent = 'üìã';
          btnCopy.title = 'Copiar link Kalodata';
          btnCopy.style.marginLeft = '5px';
          btnCopy.style.padding = '2px 6px';
          btnCopy.style.fontSize = '12px';
          btnCopy.onclick = () => {
            navigator.clipboard.writeText(kal).then(() => {
              toast.success('Link copiado al portapapeles');
            });
          };
          td.appendChild(btnCopy);
        }
      } else if (key === 'desire') {
        let current = value || '';
        td.title = current;
        const render = () => {
          td.innerHTML = '';
          const wrap = document.createElement('div');
          wrap.className = 'desire-wrap';
          wrap.textContent = current;
          td.appendChild(wrap);
          wrap.addEventListener('click', () => {
            if (td.querySelector('textarea')) return;
            const ta = document.createElement('textarea');
            ta.className = 'desire-editor';
            ta.rows = 4;
            ta.value = current;
            td.innerHTML = '';
            td.appendChild(ta);
            ta.focus();
            ta.addEventListener('blur', async () => {
              const val = ta.value.trim() || null;
              try {
                await fetch(`/api/products/${item.id}`, {
                  method: 'PATCH',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ desire: val })
                });
              } catch (e) {}
              item.desire = val;
              current = val || '';
              render();
              ecAutoFitColumns(gridRoot);
            });
          });
        };
        render();
      } else if (key === 'desire_magnitude') {
        const select = document.createElement('select');
        ['', 'Low', 'Medium', 'High'].forEach(opt => {
          const o = document.createElement('option');
          o.value = opt;
          o.textContent = opt || '‚Äî';
          if (value === opt) o.selected = true;
          select.appendChild(o);
        });
        select.addEventListener('change', async () => {
          const val = select.value || null;
          try { await api.updateProductField(item.id, { desire_magnitude: val }); } catch(e) {}
          item.desire_magnitude = val;
        });
        td.appendChild(select);
      } else if (key === 'awareness_level') {
        const select = document.createElement('select');
        ['', 'Unaware', 'Problem-Aware', 'Solution-Aware', 'Product-Aware', 'Most Aware'].forEach(opt => {
          const o = document.createElement('option');
          o.value = opt;
          o.textContent = opt || '‚Äî';
          if (value === opt) o.selected = true;
          select.appendChild(o);
        });
        select.addEventListener('change', async () => {
          const val = select.value || null;
          try { await api.updateProductField(item.id, { awareness_level: val }); } catch(e) {}
          item.awareness_level = val;
        });
        td.appendChild(select);
      } else if (key === 'competition_level') {
        const select = document.createElement('select');
        ['', 'Low', 'Medium', 'High'].forEach(opt => {
          const o = document.createElement('option');
          o.value = opt;
          o.textContent = opt || '‚Äî';
          if (value === opt) o.selected = true;
          select.appendChild(o);
        });
        select.addEventListener('change', async () => {
          const val = select.value || null;
          try { await api.updateProductField(item.id, { competition_level: val }); } catch(e) {}
          item.competition_level = val;
        });
        td.appendChild(select);
      } else if (col.type === 'number' && value !== null && value !== undefined && value !== '') {
        let num = parseFloat(String(value).replace(/[^0-9.-]+/g, ''));
        if (isNaN(num)) {
          td.textContent = '';
        } else {
          if (key === 'Item Sold' || key === 'Revenue($)' || key === 'Creator Number') {
            td.textContent = abbr(num);
          } else {
            td.textContent = num.toLocaleString();
          }
        }
      } else {
        td.textContent = value || '';
      }
      tr.appendChild(td);
    });
    // Delete button
    const tdDel = document.createElement('td');
    const btn = document.createElement('button');
    btn.textContent = '‚úñ';
    btn.title = 'Eliminar producto';
    btn.style.background = 'transparent';
    btn.style.border = 'none';
    btn.style.cursor = 'pointer';
    btn.style.color = 'red';
    btn.dataset.id = item.id;
    btn.onclick = () => {
      toast.info('¬øEliminar producto?', {actionText:'Eliminar', onAction: () => deleteProduct(item.id)});
    };
    tdDel.appendChild(btn);
    tr.appendChild(tdDel);
    tbody.appendChild(tr);
  });
  currentPageIds = products.map(p => String(p.id));
  updateResultsBadge(currentPageIds.length);
  if (window.refreshColumns) window.refreshColumns();
  if (window.applyColumnVisibility) window.applyColumnVisibility();
  updateMasterState();
  ecAutoFitColumns(gridRoot);
}

gridRoot.addEventListener('input',  e => { if (e.target.closest('td.ec-col-desire')) ecAutoFitColumns(gridRoot); });
gridRoot.addEventListener('change', e => { if (e.target.closest('td.ec-col-desire-mag, td.ec-col-awareness, td.ec-col-competition')) ecAutoFitColumns(gridRoot); });
window.addEventListener('resize', (() => { let t; return () => { clearTimeout(t); t = setTimeout(() => ecAutoFitColumns(gridRoot), 150); }; })());

function sortProducts(){
  if(!sortField) return;
  const field = sortField;
  const type = sortType;
  products.sort((a,b)=>{
    let va; let vb;
    if (field === 'id' || field === 'name' || field === 'category' || field === 'price' || field === 'image_url' || field === 'winner_score' || field === 'desire' || field === 'desire_magnitude' || field === 'awareness_level' || field === 'competition_level') {
      va = a[field];
      vb = b[field];
    } else if (metricKeys.includes(field)) {
      va = a.winner_score_breakdown && a.winner_score_breakdown.scores ? a.winner_score_breakdown.scores[field] : undefined;
      vb = b.winner_score_breakdown && b.winner_score_breakdown.scores ? b.winner_score_breakdown.scores[field] : undefined;
    } else {
      va = a.extras ? a.extras[field] : undefined;
      vb = b.extras ? b.extras[field] : undefined;
    }
    if (type === 'number') {
      const na = parseFloat(String(va).replace(/[^0-9.-]+/g, ''));
      const nb = parseFloat(String(vb).replace(/[^0-9.-]+/g, ''));
      if (isNaN(na) && isNaN(nb)) return 0;
      if (isNaN(na)) return sortDir * 1;
      if (isNaN(nb)) return sortDir * -1;
      return (na - nb) * sortDir;
    }
    const sa = (va || '').toString().toLowerCase();
    const sb = (vb || '').toString().toLowerCase();
    if (sa < sb) return -1 * sortDir;
    if (sa > sb) return 1 * sortDir;
    return 0;
  });
}

function sortBy(field, type) {
  if (sortField === field) {
    sortDir = -sortDir;
  } else {
    sortField = field;
    sortDir = 1;
    sortType = type;
  }
  sortProducts();
  renderTable();
}

document.getElementById('refreshBtn').onclick = fetchProducts;
window.onload = async () => {
  await ensureApiKey();
  await loadConfig();
  await fetchProducts();
  const tid = localStorage.getItem(IMPORT_TASK_LS_KEY);
  if (tid) {
    toast.info('Reanudando importaci√≥n previa‚Ä¶');
    const host = getGlobalProgressHost();
    const tracker = LoadingHelpers.start('Importando cat√°logo', { host });
    tracker.step(IMPORT_UPLOAD_FRAC, 'Reanudando‚Ä¶');
    window.onImportStart?.(tid);
    try {
      const result = await followImportTask(tid, tracker, { host });
      const importedCount = result?.imported ?? result?.rows_imported;
      if (Number.isFinite(importedCount) && importedCount > 0) {
        toast.success(`Importados ${importedCount}`);
      }
      tracker.step(1, 'Completado');
    } catch (err) {
      if (err?.name === 'ImportCancelledError' || err?.isCancelled) {
        tracker.step(1, 'Cancelado');
        markCancelled();
      } else {
        tracker.step(1, 'Error');
        toast.error(err?.message || 'Error en importaci√≥n');
      }
    } finally {
      localStorage.removeItem(IMPORT_TASK_LS_KEY);
      tracker.done();
      hideImportBanner();
      window.onImportEnd?.();
    }
  }
};
// Toggle config panel
document.getElementById('configBtn').onclick = async () => {
  await openConfigModal();
  const cfg = document.getElementById('config');
  const wcard = document.getElementById('weightsCard');
  const footer = document.getElementById('weightsFooter');
  if(!cfg || !wcard || !footer || !window.modalManager) return;
  const btn = document.getElementById('configBtn');
  const modal = document.createElement('div');
  modal.id = 'configModal';
  modal.className = 'modal config-modal';
  modal.setAttribute('role','dialog');
  modal.setAttribute('aria-modal','true');
  modal.setAttribute('aria-labelledby','configModalTitle');
  modal.innerHTML = `
    <header class="modal-header">
      <h3 id="configModalTitle">Configuraci√≥n</h3>
      <div class="modal-progress-slot progress-slot" aria-live="polite"></div>
      <button type="button" class="modal-close" aria-label="Cerrar">‚úï</button>
    </header>
    <div class="modal-body"></div>
  `;
  const body = modal.querySelector('.modal-body');
  const cfgParent = cfg.parentElement;
  const wParent = wcard.parentElement;
  const fParent = footer.parentElement;
  const cfgNext = cfg.nextSibling;
  const wNext = wcard.nextSibling;
  const fNext = footer.nextSibling;
  body.appendChild(cfg);
  body.appendChild(wcard);
  modal.appendChild(footer);
  cfg.style.display = 'block';
  wcard.style.display = 'block';
  footer.style.display = 'flex';
  const handle = modalManager.open(modal, {returnFocus: btn, closeOnBackdrop:true, onClose: () => {
    cfg.style.display = 'none';
    wcard.style.display = 'none';
    footer.style.display = 'none';
    cfgParent.insertBefore(cfg, cfgNext);
    wParent.insertBefore(wcard, wNext);
    fParent.insertBefore(footer, fNext);
    saveIfDirty();
  }});
  modal.querySelector('.modal-close').addEventListener('click', () => handle.close());
  modal.addEventListener('close', saveIfDirty);
  const first = modal.querySelector('input,select,textarea,button');
  if(first) first.focus();
};


// Handle file upload: clicking the upload button opens file chooser
const fileInputEl = document.getElementById('fileInput');
document.getElementById('uploadBtn').onclick = () => {
  fileInputEl.click();
};
// When a file is selected, automatically upload it
fileInputEl.onchange = async (ev) => {
  ev.preventDefault();
  const file = fileInputEl.files[0];
  if (!file) return;
  try {
    await importCatalog(file, { startUrl: IMPORT_START_URL, statusUrl: IMPORT_STATUS_URL });
  } catch (err) {
    console.error(err);
  } finally {
    fileInputEl.value = '';
  }
};
// search feature
document.getElementById('searchBtn').onclick = () => {
  const term = document.getElementById('searchInput').value.trim().toLowerCase();
  const tbody = document.querySelector('#productTable tbody');
  let visible = 0;
  Array.from(tbody.rows).forEach(row => {
    if (!term) {
      row.style.display = '';
      visible++;
      return;
    }
    const cells = Array.from(row.cells).map(td => td.textContent.toLowerCase());
    const match = cells.some(text => text.includes(term));
    row.style.display = match ? '' : 'none';
    if (match) visible++;
  });
  updateResultsBadge(visible);
};
const gptField = document.getElementById('gptPrompt');
const sendPromptBtn = document.getElementById('sendPrompt');

function autoGrow(el){
  el.style.height = 'auto';
  el.style.height = el.scrollHeight + 'px';
}

if(gptField){
  const saved = localStorage.getItem('lastGptPrompt');
  if(saved){
    gptField.value = saved;
    autoGrow(gptField);
  }
  gptField.addEventListener('input', () => {
    autoGrow(gptField);
    localStorage.setItem('lastGptPrompt', gptField.value);
  });
  gptField.addEventListener('keydown', e => {
    if(e.key === 'Enter' && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      sendPromptHandler();
    }
  });
}

async function sendPromptHandler(){
  const prompt = gptField.value.trim();
  if(!prompt){ toast.info('Escribe una consulta'); return; }
  sendPromptBtn.disabled = true;
  try {
    const data = await fetchJson('/custom_gpt', {method:'POST', body: JSON.stringify({prompt})});
    const history = document.getElementById('history');
    if(history){
      const details = document.createElement('details');
      const summary = document.createElement('summary');
      const shortPrompt = prompt.length > 40 ? prompt.substring(0,37) + '...' : prompt;
      summary.textContent = shortPrompt;
      const pre = document.createElement('pre');
      pre.textContent = data.response || data.error;
      details.appendChild(summary);
      details.appendChild(pre);
      history.prepend(details);
    }
    toast.success('Consulta enviada');
    gptField.value = '';
    localStorage.removeItem('lastGptPrompt');
    autoGrow(gptField);
  } catch(err) {
    toast.error(err.message || 'Error al enviar');
  } finally {
    sendPromptBtn.disabled = false;
  }
}

sendPromptBtn.onclick = sendPromptHandler;
document.getElementById('darkToggle').onclick = () => {
  document.body.classList.toggle('dark');
};

// Helper to parse dates from various formats (YYYY-MM-DD or other)
function parseDate(value) {
  if (!value) return null;
  // Try direct Date parse
  const d = new Date(value);
  if (!isNaN(d)) return d;
  // Try splitting by non-digit
  const parts = String(value).match(/(\d{4})[\/-]?(\d{2})[\/-]?(\d{2})/);
  if (parts) {
    const y = parseInt(parts[1]);
    const m = parseInt(parts[2]) - 1;
    const day = parseInt(parts[3]);
    return new Date(y, m, day);
  }
  return null;
}


async function postApiKey(value){
  const resp = await fetch('/api/auth/set-key', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({api_key:value})
  });
  let data = {};
  try{ data = await resp.json(); } catch{}
  if(resp.ok && data.ok){
    savedApiKeyHash = await sha256(value);
    savedApiKeyLength = value.length;
    return {ok:true};
  }
  return {ok:false, error:data.error||'Error'};
}

async function showApiKeyModal(){
  return new Promise(res=>{
    const modal=document.createElement('div');
    modal.className='modal';
    modal.setAttribute('role','dialog');
    modal.setAttribute('aria-modal','true');
    modal.innerHTML='<header class="modal-header"><h3>API Key requerida</h3></header><div class="modal-body"><input type="password" id="modalApiKey" placeholder="API Key"><div class="api-error" style="color:red"></div><button id="modalSaveApiKey">Guardar y Verificar</button></div>';
    const handle=modalManager.open(modal,{closeOnBackdrop:false});
    const input=modal.querySelector('#modalApiKey');
    const errEl=modal.querySelector('.api-error');
    modal.querySelector('#modalSaveApiKey').onclick=async()=>{
      const val=input.value.trim();
      if(!val){ toast.error('La API Key no puede estar vac√≠a'); return; }
      const r=await postApiKey(val);
      if(r.ok){ handle.close(); res(true); }
      else{ errEl.textContent=r.error||'Error'; }
    };
    input.focus();
  });
}

async function ensureApiKey(){
  try{
    let resp=await fetch('/api/auth/has-key');
    let data=await resp.json();
    while(!data.has_key){
      await showApiKeyModal();
      resp=await fetch('/api/auth/has-key');
      data=await resp.json();
    }
  }catch(err){ console.error('Error checking API key',err); }
}

document.getElementById('toggleApiKey').onclick = () => {
  showApiKeyModal();
};

const apiKeyInput = document.getElementById('apiKey');
const saveApiKeyBtn = document.getElementById('saveApiKey');

apiKeyInput.addEventListener('input', async () => {
  const val = apiKeyInput.value.trim();
  let same = false;
  if (savedApiKeyHash && val) {
    const hash = await sha256(val);
    same = hash === savedApiKeyHash;
  }
  saveApiKeyBtn.disabled = !val || same;
});

saveApiKeyBtn.addEventListener('click', async () => {
  const value = apiKeyInput.value.trim();
  if (!value) { toast.error('La API Key no puede estar vac√≠a'); return; }
  const r = await postApiKey(value);
  if(!r.ok){ toast.error('No se pudo guardar la API Key'); return; }
  toast.success('API Key guardada');
  const masked = '‚Ä¢'.repeat(Math.max(savedApiKeyLength - 4, 0)) + value.slice(-4);
  apiKeyInput.value = masked;
  saveApiKeyBtn.disabled = true;
});

// Show overlay with larger image
function showOverlay(src){
  const overlay = document.getElementById('imgOverlay');
  const img = document.getElementById('overlayImg');
  img.src = src;
  overlay.style.display = 'flex';
}
// Hide overlay only when clicking outside the image
document.getElementById('imgOverlay').onclick = (e) => {
  if (e.target.id === 'imgOverlay') {
    document.getElementById('imgOverlay').style.display = 'none';
  }
};

  // Delete a single product by ID
  async function deleteProduct(id){
    const host = getActionHost();
    const tracker = LoadingHelpers.start('Eliminando productos', { host });
    try {
      if (typeof currentGroupFilter !== 'undefined' && currentGroupFilter > 0) {
        const data = await fetchJson('/remove_from_list', {
          method:'POST',
          body: JSON.stringify({list_id: currentGroupFilter, ids: [id]}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar del grupo: '+data.error); }
        await applyGroupFilter(currentGroupFilter, { skipProgress: true, host });
      } else {
        const data = await fetchJson('/delete', {
          method:'POST',
          body: JSON.stringify({ids: [id]}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar: '+data.error); }
        await fetchProducts();
      }
    } catch(err){
      console.error(err);
      toast.error('Error al eliminar');
    } finally {
      tracker.done();
    }
  }

// Delete selected products
document.getElementById('btnDelete').onclick = () => {
  const ids = Array.from(selection, Number);
  if(!ids.length){ toast.info('Selecciona al menos un producto para eliminar'); return; }
  toast.info('¬øEliminar los productos seleccionados?', {actionText:'Eliminar', onAction: async () => {
    const host = getActionHost();
    const tracker = LoadingHelpers.start('Eliminando productos', { host });
    try{
      if (typeof currentGroupFilter !== 'undefined' && currentGroupFilter > 0) {
        const data = await fetchJson('/remove_from_list', {
          method:'POST',
          body: JSON.stringify({list_id: currentGroupFilter, ids: ids}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar del grupo: '+data.error); } else { toast.success('Eliminados del grupo: '+data.removed); }
        await applyGroupFilter(currentGroupFilter, { skipProgress: true, host });
      } else {
        const data = await fetchJson('/delete', {
          method:'POST',
          body: JSON.stringify({ids: ids}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar: '+data.error); } else { toast.success('Productos eliminados: '+data.deleted); }
        await fetchProducts();
      }
    }catch(err){
      console.error(err);
      toast.error('Error al eliminar');
    } finally {
      tracker.done();
    }
  }});
};

// Export selected products as CSV
document.getElementById('btnExport').onclick = async () => {
  const ids = Array.from(selection, Number);
  if(!ids.length){ toast.info('Selecciona productos para exportar'); return; }
  // Build query string
  const params = new URLSearchParams();
  params.set('ids', ids.join(','));
  // request export file
  const host = getActionHost();
  const tracker = LoadingHelpers.start('Exportando productos', { host });
  try{
    tracker.setStage('Preparando archivo‚Ä¶');
    params.set('format', 'xlsx');
    let response = await fetch('/api/export?' + params.toString(), { method:'GET', __hostEl: host, __skipLoadingHook: true });
    let usedFallback = false;
    if (!response.ok) {
      tracker.setStage('Generando fallback‚Ä¶');
      params.set('format', 'html');
      const fallbackRes = await fetch('/api/export?' + params.toString(), { method:'GET', __hostEl: host, __skipLoadingHook: true });
      if (!fallbackRes.ok) {
        toast.error('Error al exportar');
        return;
      }
      response = fallbackRes;
      usedFallback = true;
    }
    const blob = await response.blob();
    // determine filename from header or default
    const disposition = response.headers.get('Content-Disposition');
    let filename = usedFallback ? 'export.html' : 'export.xlsx';
    if(disposition){
      const match = disposition.match(/filename="?([^\"]+)"?/);
      if(match) filename = match[1];
    }
    tracker.step(0.7, 'Descargando‚Ä¶');
    // trigger download
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    tracker.step(1, 'Completado');
  } catch(err){
    console.error(err);
    toast.error('Error al exportar');
    tracker.step(1, 'Error');
  } finally {
    tracker.done();
  }
};

function getSelectedProductIds(){ return Array.from(selection, Number); }

// Generate Winner Score for selected or all products
document.getElementById('btnGenWinner').onclick = async () => {
  const host = getGlobalProgressHost();
  const tracker = LoadingHelpers.start('Generando Winner Score', { host });
  try {
    const ids = getSelectedProductIds();
    const rows = ids.length ? allProducts.filter(p=>ids.includes(Number(p.id))) : products;
    const payloadProducts = rows.map(p=>{
      const metrics={};
      metricKeys.forEach(k=>{ if(p[k]!==undefined) metrics[k]=p[k]; });
      return {id:p.id, metrics};
    });
    if(payloadProducts.some(p=>Object.keys(p.metrics).length<metricKeys.length)){
      toast.info('Algunos productos tienen m√©tricas faltantes');
    }
    tracker.step(0.15);
    const body = ids.length ? {product_ids: ids} : {};
    body.products = payloadProducts;
    tracker.step(0.35);
    const res = await fetch('/api/winner-score/generate?debug=1', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body),
      __hostEl: host,
      __skipLoadingHook: true
    });
    let payload = {};
    try { payload = await res.json(); }
    catch (_) { payload = {}; }
    if (!res.ok) {
      throw new Error(payload?.error || res.statusText || 'Error al recalcular');
    }
    const { processed = 0, updated = 0, diag } = payload;
    if(!processed) {
      toast.info('Nada que recalcular (0 seleccionados)');
    } else if(updated>0) {
      toast.success(`Winner Score recalculado: ${updated}/${processed} cambiaron`);
    } else {
      if(diag && diag.sum_filtered===0){
        toast.info(`Recalculado ${processed}. No afect√≥: los pesos de m√©tricas presentes suman 0 ‚Üí fallback uniforme.`);
      } else {
        toast.info(`Recalculado ${processed}. El entero 0‚Äì100 no vari√≥ (redondeo).`);
      }
    }
    tracker.step(0.7);
    if(ids.length) await reloadRows(ids, { skipProgress: true });
    else await reloadTable({ skipProgress: true });
    tracker.step(1);
  } catch(err){
    console.error(err);
    toast.error('No se pudo actualizar el Winner Score');
    tracker.step(1);
  } finally {
    tracker.done();
  }
};

// -------- Group management --------
let currentGroupFilter = -1; // -1 indicates all products

async function loadLists() {
  try {
    const select = document.getElementById('groupSelect');
    if (!select) return;
    const lists = await groupsService.listGroups();
    select.innerHTML = '';

    const allOpt = document.createElement('option');
    allOpt.value = -1;
    allOpt.textContent = 'Todos';
    select.appendChild(allOpt);

    (lists || []).forEach(lst => {
      const opt = document.createElement('option');
      opt.value = lst.id;
      opt.textContent = lst.name;
      select.appendChild(opt);
    });

    select.value = currentGroupFilter.toString();
    select.onchange = (e) => {
      const id = parseInt(e.target.value);
      applyGroupFilter(id);
    };
  } catch(err) {
    console.error(err);
  }
}

window.loadLists = loadLists;
document.addEventListener('groups-updated', () => loadLists());

async function applyGroupFilter(id, { skipProgress = false, host = null } = {}){
  if(id === -1){
    // load all products
    currentGroupFilter = -1;
    fetchProducts();
    // refresh lists to update active styling
    loadLists();
    return;
  }
  try{
    currentGroupFilter = id;
    const fetchOpts = skipProgress ? { __skipLoadingHook: true, __hostEl: host } : (host ? { __hostEl: host } : undefined);
    const data = await fetchJson('/list/' + id, fetchOpts);
    allProducts = data;
    window.allProducts = allProducts;
    selection.clear();
    renderTable();
    // refresh lists to highlight active group
    loadLists();
  } catch(err){ console.error(err); toast.error('Error al cargar lista'); }
}

// create list button
document.getElementById('createListBtn').onclick = async () => {
  const name = document.getElementById('newListName').value.trim();
  if(!name){ toast.info('Ingresa un nombre para el grupo'); return; }
  try{
    await groupsService.createGroup(name);
    document.getElementById('newListName').value = '';
    loadLists();
  }catch(err){ console.error(err); toast.error('Error al crear grupo'); }
};

// load lists on page load
window.addEventListener('DOMContentLoaded', () => {
  loadLists();
});
window.renderTable = renderTable;
window.parseDate = parseDate;
</script>
<script type="module" src="/static/js/completar-ia.js" defer></script>
<script type="module" src="/static/js/filters-panel.js" defer></script>
</body>
</html>
