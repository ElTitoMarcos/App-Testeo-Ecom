<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Product Research Copilot</title>
<link rel="stylesheet" href="/static/css/app.css">
<link rel="stylesheet" href="/static/css/theme-fixes.css">
<link rel="stylesheet" href="/static/css/toast.css">
<link rel="stylesheet" href="/static/css/loading.css">
<script type="module" src="/static/js/config.js" defer></script>
<script type="module" src="/static/js/net.js" defer></script>
<script defer src="/static/js/legacy-progress-shim.js"></script>
<style>
/* Basic layout */
body { margin:0; padding:0; font-family: 'Segoe UI', Tahoma, sans-serif; color:#222; background: linear-gradient(to bottom, #f8fbff, #e9f0ff); }
body.dark { background: #1a1b2e; color:#eaeaea; }
#app-header .app-toolbar { padding:20px; text-align:center; background: linear-gradient(90deg, #0062ff, #00c8ff); color:#fff; box-shadow:0 2px 5px rgba(0,0,0,0.3); }
body.dark #app-header .app-toolbar { background: linear-gradient(90deg, #2e2e78, #6547a6); }
.container { max-width: 1200px; margin: 0 auto; padding: 10px; }
.card { background:#121426; border:1px solid #222642; border-radius:10px; padding:12px; margin-bottom:15px; }
body.dark .card { background:#121426; border-color:#222642; }
/* Controls */
#controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
button { padding:8px 14px; border:none; border-radius:4px; cursor:pointer; background: linear-gradient(90deg,#0062ff,#00c8ff); color:#fff; font-weight:600; box-shadow:0 3px 5px rgba(0,0,0,0.2); transition:opacity 0.2s; }
button:hover { opacity:0.85; }
body.dark button { background: linear-gradient(90deg,#3a3cad,#7a53d6); color:#fff; }
/* Chip style for filter toggle */
#btnFilters { background:#e0f0ff; border:1px solid #0077cc; color:#0077cc; padding:6px 10px; border-radius:16px; font-size:14px; }
body.dark #btnFilters { background:#2a2d5c; border-color:#7a53d6; color:#a9a9ff; }
select, input[type="text"], input[type="password"] { padding:6px; border-radius:4px; border:1px solid #ccc; }
body.dark select, body.dark input[type="text"], body.dark input[type="password"] { background:#1f2344; color:#eaeaea; border-color:#444; }
th, td { padding:8px; border:1px solid #ccc; }
body.dark th, body.dark td { border-color:#444; }
tbody tr:nth-child(even) { background:#f2f6ff; }
body.dark tbody tr:nth-child(even) { background:#2a2d5c; }
body.dark tbody tr:nth-child(odd) { background:#25285a; }
tbody tr:hover {
  box-shadow: 0 0 6px rgba(0,0,0,0.2);
  transform: translateY(-2px);
  transition: box-shadow 0.2s, transform 0.2s;
}
#importBanner { background:rgba(122,83,214,0.2); color:#7a53d6; border:1px solid rgba(122,83,214,0.3); }
body.dark #importBanner { background:rgba(122,83,214,0.2); color:#c9b9f3; border:1px solid rgba(122,83,214,0.4); }
/* History & Details */
#history details { margin-bottom:8px; }
details summary { cursor:pointer; font-weight:600; color:#0062ff; }
body.dark details summary { color:#80b3ff; }
pre { white-space:pre-wrap; background:#f5f7ff; padding:8px; border-radius:4px; }
body.dark pre { background:#2e315f; }
/* Weight slider styling */
.field-label { display:block; margin-top:10px; font-weight:600; }

#section-trends[hidden]{display:none;}
#trendHeader{display:flex;flex-wrap:wrap;gap:8px;align-items:flex-end;margin-bottom:16px;}
.kpi-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-bottom:20px;}
@media (max-width:600px){.kpi-grid{grid-template-columns:repeat(2,1fr);}}
.kpi{text-align:center;padding:8px;}
.kpi-value{font-size:1.2rem;font-weight:600;}
.kpi-label{font-size:0.8rem;opacity:0.8;}
.kpi-delta{font-size:0.8rem;}
.sparklines-row{display:flex;gap:10px;margin-bottom:20px;}
.sparklines-row canvas{flex:1;height:140px;}
.trend-main{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:20px;}
.trend-main .card{flex:1;min-width:280px;max-height:320px;overflow:auto;}
.chart-wrapper{position:relative;height:240px;}
.metric-selector{display:flex;gap:4px;margin-left:auto;}
.metric-btn{padding:4px 8px;font-size:12px;}
.metric-btn.active{opacity:0.7;}
.skeleton{background:#ddd;border-radius:4px;height:40px;animation:skeleton-pulse 1.2s infinite ease-in-out;}
body.dark .skeleton{background:#333;}
@keyframes skeleton-pulse{0%{opacity:0.7;}50%{opacity:0.4;}100%{opacity:0.7;}}

/* Oculta KPIs si a√∫n existen en el DOM */
.kpi-grid, .kpi, .kpis { display: none !important; }

/* Fila de gr√°ficos */
.trends-row {
  display: grid;
  grid-template-columns: 2fr 1.2fr;
  gap: 16px;
  margin-top: 8px;
}

/* Cards y lienzos */
#section-trends .card { background: var(--panel, #171a2b); border-radius: 10px; padding: 12px; }
#section-trends .card.lg { min-height: 380px; }
#section-trends .card.md { min-height: 380px; }
#section-trends .card-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
#topCategoriesChart, #priceIncomeScatter { width:100%; height:100%; }

/* Tabla compacta */
.table.compact th, .table.compact td { padding: 8px 10px; }
.table.compact th[role="button"] { cursor: pointer; user-select: none; }
.table.compact th.sort-asc::after  { content: " \25B2"; opacity: .7; }
.table.compact th.sort-desc::after { content: " \25BC"; opacity: .7; }

</style>
</head>
<body class="dark">
<header id="topBar" class="app-header">
  <div id="app-header">
    <div class="app-toolbar" style="padding:8px 15px; display:flex; align-items:center; justify-content:space-between; position:relative;">
      <div style="display:flex; align-items:center; gap:8px;">
        <h1 style="margin:0; font-size:1.4rem;">Ecom Testing App</h1>
        <p style="margin:0;font-size:12px; opacity:0.8;">By El Tito ü§ô</p>
      </div>
      <div style="flex:1; display:flex; justify-content:flex-end; gap:8px; align-items:center;">
        <input type="file" id="fileInput" style="display:none;" />
        <button id="uploadBtn" title="Subir archivo">üì§</button>
        <button id="refreshBtn" title="Actualizar lista">üîÑ</button>
        <button id="btn-ver-tendencias" title="Ver tendencias" data-action="toggle-trends">üìä</button>
        <button id="darkToggle" title="Modo oscuro">üåô</button>
        <button id="configBtn" title="Configuraci√≥n avanzada">‚öôÔ∏è</button>
      </div>
    </div>
    <div id="global-progress-wrapper">
      <div id="progress-slot-global" class="progress-slot" aria-live="polite"></div>
      <button id="progress-cancel-btn" type="button" aria-label="Cancelar">Cancelar</button>
    </div>
  </div>
  <!-- Search bar row with controls -->
  <div id="searchRow">
    <input type="text" id="searchInput" placeholder="Buscar producto o palabra clave..." aria-label="Buscar productos" />
    <button id="searchBtn">Buscar</button>
    <button id="btnFilters">Filtros</button>
    <div id="activeFilterChips"></div>
    <input type="text" id="newListName" placeholder="Nombre del grupo" style="padding:4px; min-width:120px;">
    <button id="createListBtn">Crear</button>
    <textarea id="gptPrompt" rows="1" maxlength="2000" placeholder="Escribe consulta para GPT..." aria-label="Escribe consulta para GPT..."></textarea>
    <div id="gptActions">
      <button id="sendPrompt">Enviar consulta a GPT</button>
      <button id="btnGenWinner" class="bar-btn" disabled title="Generar Winner Score" aria-label="Generar Winner Score">Generar Winner Score</button>
    </div>
    <div id="searchRowRight">
      <div id="listMeta">0 resultados</div>
    </div>
  </div>
</header>
<div id="importBanner" style="display:none; padding:8px; text-align:center;"></div>
<div id="config" style="display:none;">
  <div class="config-controls">
    <label for="modelSelect">Modelo</label>
    <select id="modelSelect">
      <option value="gpt-4o">GPT-4o</option>
      <option value="gpt-4">GPT-4</option>
      <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
    </select>
    <button id="toggleApiKey" type="button" style="display:none;">Cambiar API Key</button>
  </div>
  <div class="api-row">
    <label for="apiKey">API Key</label>
    <div class="api-input-row">
      <input type="password" id="apiKey" />
      <button id="saveApiKey" disabled aria-label="Guardar API Key" title="Guardar API Key">Guardar API Key</button>
    </div>
  </div>
</div>
<div id="weightsCard" class="card" style="display:none;">
  <strong>Ponderaciones Winner Score</strong>
  <div class="legend">‚ÑπÔ∏è Arrastra para reordenar. M√°s arriba = mayor prioridad. El n√∫mero (0‚Äì100) es el peso.</div>
  <ul id="weightsList" class="weights-list"></ul>
</div>
<div id="weightsFooter" class="config-footer" style="display:none;">
  <button id="btnReset" class="btn">Reset</button>
  <button id="btnAiWeights" class="btn primary">Ajustar pesos con IA</button>
</div>
<div id="custom" style="display:none;">
  <div id="history" style="margin-top:10px;"></div>
</div>
<section id="section-trends" hidden>
  <div id="trendHeader">
    <label>Desde: <input type="text" id="fecha-desde"></label>
    <label>Hasta: <input type="text" id="fecha-hasta"></label>
    <button id="btn-aplicar-tendencias" aria-label="Aplicar filtros">Aplicar</button>
  </div>
  <div id="trends-status"></div>
  <section id="trends" class="trends-grid" hidden>
    <div class="card" id="top-left">
      <div class="chart-header">
        <h4>Top categor√≠as</h4>
        <button class="chart-help" aria-label="Ayuda gr√°fico top categor√≠as"
                data-tip="Barras: valor de la m√©trica seleccionada para cada categor√≠a (ordenadas de mayor a menor). Eje: escala lineal. Pasa el rat√≥n para ver el detalle.">
          i
        </button>
      </div>
      <div class="chart-wrap chart-wrap--sm">
        <canvas id="topCategoriesChart"></canvas>
      </div>
    </div>

    <div class="card" id="top-right">
      <div class="chart-header">
        <h4>Pareto de ingresos (Top 15)</h4>
        <button class="chart-help" aria-label="Ayuda gr√°fico pareto"
                data-tip="Barras: ingresos por categor√≠a (ordenadas desc). L√≠nea: % acumulado (eje derecho) que muestra qu√© porcentaje del total se alcanza al sumar desde la categor√≠a m√°s alta. Eje izquierdo: ‚Ç¨ ingresos. Eje derecho: porcentaje.">
          i
        </button>
      </div>
      <div class="chart-wrap">
        <canvas id="paretoRevenueChart"></canvas>
      </div>
    </div>
  </section>

  <section id="trends-bottom" class="two-col" hidden>
    <div class="card">
      <table id="trendsTable" class="table table--compact">
        <thead>
          <tr>
            <th data-key="path" data-type="text">Categor√≠as</th>
            <th data-key="products" data-type="num">Productos</th>
            <th data-key="units" data-type="num">Unidades</th>
            <th data-key="revenue" data-type="num">Ingresos</th>
            <th data-key="price" data-type="num">Precio</th>
            <th data-key="rating" data-type="num">Rating</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <aside class="card" id="trendsInsights">
      <div class="insights-toolbar">
        <button id="btnLocalInsights" class="btn btn--sm">Generar insights (local)</button>
      </div>
      <div id="insightsContent" class="insights-content">
        <p class="muted">Aqu√≠ aparecer√°n hallazgos relevantes sobre las categor√≠as (tendencias, outliers, pareto‚Ä¶).</p>
      </div>
    </aside>
  </section>
</section>

<section id="section-products">
  <table id="productTable">
  <thead class="sticky-thead">
    <tr id="headerRow"></tr>
  </thead>
  <tbody></tbody>
  </table>
  <div id="bottomBar" class="bottombar hidden">
  <button id="legendBtn" class="legend-btn" title="Mostrar leyenda" aria-label="Mostrar leyenda">‚ÑπÔ∏è</button>
  <span id="selCount"></span>
  <select id="groupSelect" aria-label="Filtrar por grupo"></select>
  <button id="btnAddToGroup" class="bar-btn" disabled title="A√±adir seleccionados al grupo" aria-label="A√±adir seleccionados al grupo">A√±adir a grupo</button>
  <button id="btnManageGroups" class="bar-btn" title="Gestionar grupos" aria-label="Gestionar grupos">Gestionar grupos</button>
  <button id="btnDelete" class="bar-btn" disabled title="Eliminar seleccionados" aria-label="Eliminar seleccionados">Eliminar</button>
        <button id="btnExport" class="bar-btn" disabled title="Exportar seleccionados" aria-label="Exportar seleccionados">Exportar</button>
  <button id="btnColumns" class="bar-btn" title="Gestionar columnas" aria-label="Gestionar columnas">Columnas</button>
  </div>
  <div id="legendPop" class="popover hidden">
  <div>‚Ä¢ Fila roja: duplicado</div>
  </div>
  <div id="columnsPanel" class="popover hidden"></div>
</section>

<!-- Overlay for viewing images in larger size -->
<div id="imgOverlay" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.8); justify-content:center; align-items:center; z-index:1000;">
  <img id="overlayImg" src="" style="max-width:90%; max-height:90%; box-shadow:0 0 10px #000; border-radius:8px;" />
</div>
<div id="filtersDrawer" class="drawer right hidden">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <h3>Filtros</h3>
    <button id="closeFilters">√ó</button>
  </div>
  <div class="filters-grid">
    <!-- ID -->
    <label>ID</label>
    <input id="f-id" placeholder="e.g. 1,3-7">

    <!-- Categor√≠a -->
    <label>Categor√≠a</label>
    <input id="f-category" placeholder="contiene‚Ä¶">

    <!-- Price -->
    <label>Precio m√≠n</label>
    <input id="f-price-min" inputmode="decimal" placeholder="‚Ç¨">
    <label>Precio m√°x</label>
    <input id="f-price-max" inputmode="decimal" placeholder="‚Ç¨">

    <!-- Rating -->
    <label>Rating m√≠n</label>
    <input id="f-rating-min" inputmode="decimal" placeholder="0‚Äì5">
    <label>Rating m√°x</label>
    <input id="f-rating-max" inputmode="decimal" placeholder="0‚Äì5">

    <!-- Unidades vendidas -->
    <label>Unidades m√≠n</label>
    <input id="f-units-min" inputmode="numeric" placeholder="K/M ok">
    <label>Unidades m√°x</label>
    <input id="f-units-max" inputmode="numeric" placeholder="K/M ok">

    <!-- Ingresos -->
    <label>Ingresos m√≠n</label>
    <input id="f-revenue-min" inputmode="decimal" placeholder="‚Ç¨ K/M ok">
    <label>Ingresos m√°x</label>
    <input id="f-revenue-max" inputmode="decimal" placeholder="‚Ç¨ K/M ok">

    <!-- Tasa de conversi√≥n -->
    <label>Conv. m√≠n</label>
    <input id="f-conv-min" inputmode="decimal" placeholder="%">
    <label>Conv. m√°x</label>
    <input id="f-conv-max" inputmode="decimal" placeholder="%">

    <!-- Fecha lanzamiento -->
    <label>Fecha desde</label>
    <input id="f-date-from" type="date">
    <label>Fecha hasta</label>
    <input id="f-date-to" type="date">

    <!-- Rango Fechas (columna texto) -->
    <label>Rango Fechas</label>
    <input id="f-range-text" placeholder="contiene‚Ä¶">

    <!-- Desire magnitude -->
    <label>Desire magnitude</label>
    <select id="f-desire-mag">
      <option value="">Cualquiera</option>
      <option>Low</option><option>Medium</option><option>High</option>
    </select>

    <!-- Awareness level -->
    <label>Awareness level</label>
    <select id="f-awareness">
      <option value="">Cualquiera</option>
      <option value="unaware">Unaware</option>
      <option value="problemaware">Problem-Aware</option>
      <option value="solutionaware">Solution-Aware</option>
      <option value="productaware">Product-Aware</option>
      <option value="mostaware">Most Aware</option>
    </select>

    <!-- Competition level -->
    <label>Competition level</label>
    <select id="f-competition">
      <option value="">Cualquiera</option>
      <option>Low</option><option>Medium</option><option>High</option>
    </select>

    <!-- Winner Score -->
    <label>Winner Score m√≠n</label>
    <input id="f-score-min" inputmode="numeric" placeholder="0‚Äì100">
    <label>Winner Score m√°x</label>
    <input id="f-score-max" inputmode="numeric" placeholder="0‚Äì100">
  </div>
  <div style="display:flex; gap:8px; margin-top:12px;">
    <button id="applyFilters" style="flex:1;">Aplicar</button>
    <button id="clearFilters" style="flex:1;">Limpiar</button>
  </div>
</div>
<script type="module" src="/static/js/loading.js" defer></script>
<script src="/static/js/overlay.js" defer></script>
<script src="/static/js/toast.js" defer></script>
<script src="/static/js/table.js" defer></script>
<script src="/static/js/columns.js" defer></script>
<script type="module" src="/static/js/add-group.js" defer></script>
<script type="module" src="/static/js/manage-groups.js" defer></script>
<script src="/static/js/winner_score.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" defer></script>
<script type="module" src="/static/js/trends-summary.js" defer></script>
<script type="module" src="/static/js/trends-insights.js" defer></script>
<script type="module" src="/static/js/table-sort.js" defer></script>
<script type="module" src="/static/js/help-tooltip.js" defer></script>
<script type="module" defer>
import { applyFilters, readFilters } from '/static/js/filters-panel.js';
import * as api from "/static/js/net.js";
import * as groupsService from "/static/js/groups-service.js";
import { LoadingHelpers } from '/static/js/loading.js';
const { fetchJson } = api;
const metricKeys = window.metricKeys;
const openConfigModal = window.openConfigModal;
const saveIfDirty = window.saveIfDirty;
window.fetchJson = fetchJson;
window.groupsService = groupsService;
const IMPORT_TASK_LS_KEY = 'last_import_task';

// ===== ETA por producto + Watchdog =====
let etaTimer = null;
let etaStart = 0;
let etaTotalMs = 0;
let etaLastPct = 0;
let etaFinished = false;

// Se√±ales backend
let lastBackendSignalAt = 0;
let sawBackendActivity = false;
let watchdogTimer = null;

const ETA_MIN = 3.4;
const ETA_MAX = 3.7;
const ETA_DEFAULT = 3.55; // antes 3.65
const ETA_SECONDS_PER_ITEM = ETA_DEFAULT;

const WATCHDOG_CHECK_MS = 1500;
const WATCHDOG_IDLE_MS = 10000;
const WATCHDOG_PCT_GATE = 80;

let etaTracker = null;

function setEtaTracker(tracker) {
  etaTracker = tracker || null;
}

function syncEtaToTracker(pct) {
  if (!etaTracker || typeof etaTracker.step !== 'function') return;
  const frac = Math.max(0, Math.min(1, pct / 100));
  try { etaTracker.step(frac); } catch (_) {}
}

function startEtaProgress(totalItems, secondsPerItem = ETA_DEFAULT) {
  stopEtaProgress(false);
  etaFinished = false;

  if (!Number.isFinite(totalItems) || totalItems <= 0) totalItems = 1;
  const spi = Math.max(ETA_MIN, Math.min(ETA_MAX, secondsPerItem));

  etaTotalMs = Math.max(500, Math.round(totalItems * spi * 1000));
  etaStart = Date.now();
  etaLastPct = 0;

  lastBackendSignalAt = 0;
  sawBackendActivity = false;

  setProgressUI(0);

  etaTimer = setInterval(() => {
    if (etaFinished) return;

    const elapsed = Date.now() - etaStart;
    const raw = (elapsed / etaTotalMs) * 100;
    const pct = Math.max(0, Math.min(99, Math.floor(raw)));

    if (pct > etaLastPct) {
      etaLastPct = pct;
      setProgressUI(pct);
    }
  }, 150);

  watchdogTimer = setInterval(() => {
    if (etaFinished) return clearInterval(watchdogTimer);
    const now = Date.now();
    const pctNow = etaLastPct;

    if (sawBackendActivity &&
        pctNow >= WATCHDOG_PCT_GATE &&
        lastBackendSignalAt > 0 &&
        (now - lastBackendSignalAt) >= WATCHDOG_IDLE_MS) {
      console.debug('[watchdog] cierre por silencio backend con ETA alta');
      markBackendDone();
    }
  }, WATCHDOG_CHECK_MS);
}

function stopEtaProgress(done) {
  if (etaTimer) { clearInterval(etaTimer); etaTimer = null; }
  if (watchdogTimer) { clearInterval(watchdogTimer); watchdogTimer = null; }
  if (done) {
    etaFinished = true;
    setProgressUI(100);
  }
}

function markBackendDone() {
  if (etaFinished) return;
  stopEtaProgress(true);
  refreshProductsTable();
}

async function refreshProductsTable() {
  try {
    if (window.table && table.ajax && typeof table.ajax.reload === 'function') {
      table.ajax.reload(null, false);
      return;
    }
    if (typeof window.reloadProductsTable === 'function') {
      await window.reloadProductsTable();
      return;
    }
    if (typeof window.fetchProductsAndRender === 'function') {
      await window.fetchProductsAndRender();
      return;
    }
    location.reload();
  } catch (e) {
    console.error('Error refrescando tabla:', e);
    location.reload();
  }
}

function setProgressUI(pct) {
  const bar = document.querySelector('.progress-fill, #import-progress .bar, [role="progressbar"] .bar');
  if (bar) bar.style.width = pct + '%';

  const label = document.querySelector('.progress-percent, #import-progress .percent');
  if (label) label.textContent = pct + '%';

  const topLabel = document.querySelector('#top-import-label, .import-status-text');
  if (topLabel) topLabel.textContent = pct + '%';

  syncEtaToTracker(pct);
}

function wireJobDoneSignals({ jobId, sseUrl, pollUrl, totalItems }) {
  if (sseUrl) {
    try {
      const es = new EventSource(sseUrl);
      const close = () => { try { es.close(); } catch {} };

      const onMessage = (raw) => {
        backendHeartbeat();
        const msg = parseSseData(raw?.data);
        if (isDoneMsg(msg, totalItems)) {
          close();
          markBackendDone();
        }
      };

      es.addEventListener('message', (e) => onMessage(e));
      es.addEventListener('done', (e) => onMessage(e));
      es.addEventListener('complete', (e) => onMessage(e));
      es.addEventListener('finished', (e) => onMessage(e));

      es.addEventListener('error', () => {
        close();
        if (pollUrl) startPolling(pollUrl, totalItems);
      });

      return;
    } catch {
      // continuamos con polling
    }
  }

  if (pollUrl) startPolling(pollUrl, totalItems);
}

function startPolling(url, totalItems) {
  const iv = setInterval(async () => {
    if (etaFinished) return clearInterval(iv);
    try {
      const r = await fetch(url, { cache: 'no-store' });
      backendHeartbeat();
      let j = null;
      try { j = await r.json(); } catch {}
      if (isDoneMsg(j, totalItems)) {
        clearInterval(iv);
        markBackendDone();
      }
    } catch {
      // ignoramos y seguimos
    }
  }, 1200);
}

function backendHeartbeat() {
  lastBackendSignalAt = Date.now();
  sawBackendActivity = true;
}

function parseSseData(data) {
  if (!data) return null;
  if (typeof data === 'string') {
    try { return JSON.parse(data); }
    catch { return { _text: data }; }
  }
  if (typeof data === 'object') return data;
  return null;
}

function isDoneMsg(m, totalItems) {
  if (!m) return false;

  const text = (m._text || m.message || '').toString();
  if (text.includes('ai.run done')) return true;
  if (text.toLowerCase().includes('completed') || text.toLowerCase().includes('finished')) return true;

  const norm = (v) => (v == null ? '' : String(v)).toLowerCase();
  const tnum = (v) => { const n = Number(v); return Number.isFinite(n) ? n : NaN; };

  const phase = norm(m.phase || m.stage);
  const status = norm(m.status || m.state);
  const pending = tnum(m.pending ?? m.remaining);
  const remaining = tnum(m.remaining ?? m.pending);
  const processed = tnum(m.processed ?? m.done ?? m.parsed);
  const total = tnum(m.total ?? m.items ?? totalItems);

  const notAiPhases = ['upload','import','parse','parsed','queued','triage','reading'];
  if (phase && notAiPhases.includes(phase)) return false;

  if (status === 'done' || status === 'ok' || status === 'completed' || status === 'finished') {
    if (Number.isFinite(remaining) && remaining === 0) return true;
    if (Number.isFinite(pending) && pending === 0) return true;
    if (Number.isFinite(processed) && Number.isFinite(total) && total > 0 && processed >= total) return true;
  }

  if (Number.isFinite(remaining) && remaining === 0) return true;
  if (Number.isFinite(pending) && pending === 0) return true;
  if (Number.isFinite(processed) && Number.isFinite(total) && total > 0 && processed >= total) return true;

  return false;
}

Object.assign(window, {
  startEtaProgress,
  stopEtaProgress,
  markBackendDone,
  wireJobDoneSignals,
  refreshProductsTable,
});

// ==== Progreso y endpoints ====

function pickEtaTotal(source) {
  if (!source || typeof source !== 'object') return null;
  const candidates = [
    source.total,
    source.expected,
    source.rows_total,
    source.rows_expected,
    source.rows_imported,
    source.imported,
    source.count,
    source.items,
    source.items_count,
    source.config?.expected,
  ];
  for (const candidate of candidates) {
    const num = Number(candidate);
    if (Number.isFinite(num) && num > 0) return num;
  }
  return null;
}

function ensureEtaFromSource(source, secondsPerItem = ETA_SECONDS_PER_ITEM) {
  if (etaTimer || etaFinished) return false;
  const total = pickEtaTotal(source);
  if (Number.isFinite(total) && total > 0) {
    startEtaProgress(total, secondsPerItem);
    return true;
  }
  return false;
}

const IMPORT_STATUS_URL = '/_import_status';
const IMPORT_START_URL  = '/upload';

// IA (ajusta si tus rutas cambian en backend)
const AI_START_URL   = '/_ai_fill/start';
const AI_STATUS_URL  = '/_ai_fill/status';
const AI_CANCEL_URL  = '/_ai_fill/cancel';
let savedApiKeyHash = null;
let savedApiKeyLength = 0;

const getGlobalProgressHost = () => document.querySelector('#progress-slot-global');
const getActionHost = () => document.querySelector('#bottomBar') || getGlobalProgressHost();

const AI_EVENTS_URL = '/events/ai';
let __aiEventsInitialized = false;
let __aiEventSource = null;
let __aiPollTimer = null;
let __aiLastMessageAt = 0;

function __extractAiPercent(msg) {
  if (!msg || typeof msg !== 'object') return null;
  const fields = [msg.percent, msg.pct, msg.progress];
  for (const field of fields) {
    const num = Number(field);
    if (Number.isFinite(num)) {
      if (field === msg.progress) {
        return Math.max(0, Math.min(100, num * 100));
      }
      return Math.max(0, Math.min(100, num));
    }
  }
  const processed = Number(msg.processed);
  const total = Number(msg.total);
  if (Number.isFinite(processed) && Number.isFinite(total) && total > 0) {
    return Math.max(0, Math.min(100, (processed / Math.max(total, 1)) * 100));
  }
  return null;
}

function __setAiStage(label) {
  if (!label) return;
  try {
    if (window.__activeAITracker && typeof window.__activeAITracker.setStage === 'function') {
      window.__activeAITracker.setStage(label);
    } else {
      const stageEl = document.querySelector('#progress-slot-global .progress-stage');
      if (stageEl) stageEl.textContent = label;
    }
  } catch (_) {
    // ignore
  }
}

async function __triggerProductsReload() {
  try {
    if (typeof window.refreshProductsTable === 'function') {
      await window.refreshProductsTable();
      return;
    }
    if (typeof window.reloadTable === 'function') {
      await window.reloadTable({ skipProgress: true });
      return;
    }
  } catch (_) {
    // continue to fallback
  }
  try {
    if (typeof window.fetchProductsAndRender === 'function') {
      await window.fetchProductsAndRender();
      return;
    }
  } catch (_) {
    // ignore and fallback to reload below
  }
  try {
    location.reload();
  } catch (_) {
    // noop
  }
}

function __handleAiEvent(msg) {
  if (!msg || typeof msg !== 'object') return;
  const type = String(msg.type || msg.event || '').toLowerCase();
  if (!type) return;
  __aiLastMessageAt = Date.now();
  const pct = __extractAiPercent(msg);
  if (Number.isFinite(pct) && typeof window.setProgressUI === 'function') {
    window.setProgressUI(Math.round(pct));
  }
  const status = String(msg.status || '').toLowerCase();
  if (type === 'ai.progress') {
    if (status === 'canceling') {
      __setAiStage('Cancelando‚Ä¶');
    } else {
      __setAiStage('IA generando‚Ä¶');
    }
  } else if (type === 'ai.done') {
    if (status === 'canceled') {
      __setAiStage('Cancelado');
      if (typeof window.stopEtaProgress === 'function') window.stopEtaProgress(false);
    } else {
      __setAiStage('Completado');
      if (typeof window.markBackendDone === 'function') window.markBackendDone();
    }
  } else if (type === 'ai.error') {
    __setAiStage('Error');
    if (typeof window.stopEtaProgress === 'function') window.stopEtaProgress(false);
  }

  if (type === 'products.reload' || type === 'products.updated' || (type === 'ai.done' && status === 'done')) {
    __triggerProductsReload();
  }
}

function __startAiPolling() {
  if (__aiPollTimer) clearInterval(__aiPollTimer);
  __aiPollTimer = window.setInterval(async () => {
    if (Date.now() - __aiLastMessageAt < 4000) return;
    try {
      const resp = await fetch('/api/ai/progress', { cache: 'no-store', __skipLoadingHook: true });
      if (!resp.ok) return;
      const data = await resp.json();
      if (!data || typeof data !== 'object') return;
      const status = String(data.status || '').toLowerCase();
      let type = 'ai.progress';
      if (status === 'error') type = 'ai.error';
      else if (status === 'done' || status === 'canceled') type = 'ai.done';
      __handleAiEvent({ ...data, type });
    } catch (_) {
      // ignore errors
    }
  }, 1500);
}

function setupAiEvents() {
  if (__aiEventsInitialized) return;
  __aiEventsInitialized = true;
  __startAiPolling();
  if (!window.EventSource) return;
  try {
    const es = new EventSource(AI_EVENTS_URL);
    __aiEventSource = es;
    es.onmessage = (event) => {
      if (!event || typeof event.data !== 'string') return;
      try {
        const payload = JSON.parse(event.data);
        __handleAiEvent(payload);
      } catch (_) {
        // ignore payload parse errors
      }
    };
    es.onerror = () => {
      __aiLastMessageAt = Date.now();
    };
  } catch (_) {
    __aiEventSource = null;
  }
}

if (document.readyState === 'loading') {
  window.addEventListener('DOMContentLoaded', setupAiEvents);
} else {
  setupAiEvents();
}

function formatPrice(n) {
  const num = Number(n);
  return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 })
    .format(Number.isFinite(num) ? num : 0);
}

function showImportBanner(msg) {
  const b = document.getElementById('importBanner');
  if (!b) return;
  b.textContent = msg;
  b.style.display = 'block';
}

function hideImportBanner() {
  const b = document.getElementById('importBanner');
  if (b) b.style.display = 'none';
}

async function sha256(str) {
  const buf = new TextEncoder().encode(str);
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  return Array.from(new Uint8Array(hashBuf))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// ==== Cancelaci√≥n global de la carga (import/IA) ====
const cancelBtn = document.getElementById('progress-cancel-btn');
let __cancelRequested = false;
let __activeUploadXhr = null;   // para abort() de la subida
let __activeAIJobId   = null;   // para cancelar en backend
function showCancelButton(onClick) {
  cancelBtn.onclick = onClick;
  cancelBtn.style.display = 'inline-flex';
}
function hideCancelButton() {
  cancelBtn.style.display = 'none';
  cancelBtn.onclick = null;
}

async function followImportTask(taskId, tracker, {
  statusUrl = IMPORT_STATUS_URL,
  host = getGlobalProgressHost(),
  stopOnDone = true,
  secondsPerItem = ETA_SECONDS_PER_ITEM,
} = {}) {
  const id = typeof taskId === 'string' ? taskId : String(taskId || '');
  if (!id) return null;
  while (true) {
    if (__cancelRequested) {
      throw new DOMException('Importaci√≥n cancelada', 'AbortError');
    }
    let data;
    try {
      const resp = await fetch(`${statusUrl}?task_id=${encodeURIComponent(id)}&t=${Date.now()}`,
        { __skipLoadingHook: true, __hostEl: host, cache: 'no-store' }
      );
      if (!resp.ok) throw new Error('Estado no disponible');
      data = await resp.json();
    } catch (err) {
      await sleep(900);
      continue;
    }
    if (data.ui_cost_message) showImportBanner(data.ui_cost_message);
    const stage = (data.message || data.stage || data.state || '').toString() || 'Procesando‚Ä¶';
    tracker?.setStage(stage);
    ensureEtaFromSource(data, secondsPerItem);

    const statusVal = String(data.state || data.status || '').toLowerCase();
    if (statusVal === 'error' || data.error) {
      stopEtaProgress(false);
      throw new Error(data.error || 'Error en importaci√≥n');
    }
    if (statusVal === 'cancelled' || statusVal === 'canceled') {
      stopEtaProgress(false);
      throw new DOMException('Importaci√≥n cancelada', 'AbortError');
    }
    if (statusVal === 'unknown' || !statusVal) {
      stopEtaProgress(false);
      throw new Error('Estado de importaci√≥n desconocido');
    }
    const doneFlag = statusVal === 'done' || statusVal === 'completed' || statusVal === 'finished' || data.done;
    if (doneFlag) {
      if (stopOnDone) {
        await markBackendDone();
      } else {
        stopEtaProgress(false);
        await reloadTable({ skipProgress: true });
      }
      hideImportBanner();
      return data;
    }
    await sleep(450);
  }
}

async function importCatalog(file, {
  startUrl = IMPORT_START_URL,
  statusUrl = IMPORT_STATUS_URL,
  withAI = false,
  aiStartUrl = AI_START_URL,
  aiStatusUrl = AI_STATUS_URL,
  aiCancelUrl = AI_CANCEL_URL
} = {}) {
  if (!file) throw new Error('Archivo no v√°lido');
  const host = getGlobalProgressHost();
  const tracker = LoadingHelpers.start('Importando cat√°logo', { host });
  setEtaTracker(tracker);
  setProgressUI(0);
  tracker.setStage('Subiendo archivo‚Ä¶');
  showCancelButton(() => {
    __cancelRequested = true;
    try { __activeUploadXhr?.abort(); } catch {}
  });
  __cancelRequested = false;
  let lastResult = null;
  let finalCleanupHandled = false;
  try {
    const fd = new FormData();
    fd.append('file', file);
    const xhr = new XMLHttpRequest();
    __activeUploadXhr = xhr;
    xhr.responseType = 'json';
    xhr.__skipLoadingHook = true;
    xhr.__hostEl = host;
    const startResult = await new Promise((resolve, reject) => {
      xhr.open('POST', startUrl, true);
      xhr.upload.onprogress = () => {
        // El progreso depende solo del reloj; mantiene la etapa visible.
        tracker.setStage('Subiendo archivo‚Ä¶');
      };
      xhr.onabort = () => reject(new DOMException('Importaci√≥n cancelada', 'AbortError'));
      xhr.onerror = () => reject(new Error('Error de red subiendo archivo'));
      xhr.onload = () => {
        let payload = xhr.response;
        if (!payload && xhr.responseText) {
          try { payload = JSON.parse(xhr.responseText); }
          catch (e) { payload = null; }
        }
        const ok = xhr.status >= 200 && xhr.status < 300;
        if (!ok || !payload) {
          const message = payload?.error || payload?.message || 'Respuesta inv√°lida al iniciar importaci√≥n';
          reject(new Error(message));
          return;
        }
        ensureEtaFromSource(payload, ETA_SECONDS_PER_ITEM);
        if (payload.task_id) {
          resolve({ kind: 'async', taskId: payload.task_id, data: payload });
          return;
        }
        resolve({ kind: 'sync', data: payload });
      };
      xhr.send(fd);
    });

    if (startResult.kind === 'sync') {
      lastResult = startResult.data;
      ensureEtaFromSource(lastResult, ETA_SECONDS_PER_ITEM);
      if (!etaTimer) {
        const fallbackTotal = lastResult?.imported ?? lastResult?.rows_imported ?? 1;
        startEtaProgress(Number(fallbackTotal) || 1, ETA_SECONDS_PER_ITEM);
      }
      const importedCount = lastResult?.imported ?? lastResult?.rows_imported;
      if (Number.isFinite(importedCount) && importedCount > 0) {
        toast.success(`Importados ${importedCount}`);
      }
      if (withAI) {
        await runAIFillPhase({
          tracker,
          aiStartUrl, aiStatusUrl, aiCancelUrl,
          importedCount,
          secondsPerItem: ETA_SECONDS_PER_ITEM
        });
        tracker.done();
        finalCleanupHandled = true;
      } else {
        await markBackendDone();
        tracker.setStage('Completado');
      }
      return lastResult;
    }

    const taskId = startResult.taskId;
    const idStr = typeof taskId === 'string' ? taskId : String(taskId);
    tracker.setStage('Archivo subido');
    localStorage.setItem(IMPORT_TASK_LS_KEY, idStr);

    lastResult = await followImportTask(idStr, tracker, {
      statusUrl,
      host,
      stopOnDone: !withAI,
      secondsPerItem: ETA_SECONDS_PER_ITEM,
    });

    const importedCount = lastResult?.imported ?? lastResult?.rows_imported;
    if (Number.isFinite(importedCount) && importedCount > 0) {
      toast.success(`Importados ${importedCount}`);
    }
    ensureEtaFromSource(lastResult, ETA_SECONDS_PER_ITEM);
    if (withAI) {
      await runAIFillPhase({
        tracker,
        aiStartUrl, aiStatusUrl, aiCancelUrl,
        importedCount,
        secondsPerItem: ETA_SECONDS_PER_ITEM
      });
      tracker.done();
      finalCleanupHandled = true;
    } else {
      await markBackendDone();
      tracker.setStage('Completado');
    }
    return lastResult;
  } catch (err) {
    if (__cancelRequested || err?.name === 'AbortError') {
      tracker.setStage('Cancelado');
      stopEtaProgress(false);
    } else {
      tracker.setStage('Error');
      stopEtaProgress(false);
      toast.error(err?.message || 'Error al importar cat√°logo');
    }
    throw err;
  } finally {
    __activeUploadXhr = null;
    localStorage.removeItem(IMPORT_TASK_LS_KEY);
    hideImportBanner();
    if (!finalCleanupHandled) {
      tracker.done();
    }
    hideCancelButton();
    __cancelRequested = false;
    setEtaTracker(null);
  }
}

async function runAIFillPhase({ tracker, aiStartUrl, aiStatusUrl, aiCancelUrl, importedCount, secondsPerItem = ETA_SECONDS_PER_ITEM }) {
  // 1) Iniciar job IA
  window.__activeAITracker = tracker || null;
  tracker.setStage('Preparando IA‚Ä¶');
  let startData;
  try {
    const resp = await fetch(aiStartUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ imported: importedCount || 0 }),
      __skipLoadingHook: true,
      __hostEl: getGlobalProgressHost()
    });
    if (!resp.ok) throw new Error('No se pudo iniciar IA');
    startData = await resp.json();
  } catch (e) {
    tracker.setStage('Error al iniciar IA');
    stopEtaProgress(false);
    window.__activeAITracker = null;
    throw e;
  }

  ensureEtaFromSource(startData, secondsPerItem);
  if (!etaTimer) {
    const fallback = startData?.total ?? importedCount ?? 1;
    startEtaProgress(Number(fallback) || 1, secondsPerItem);
  }

  const total     = Number(startData?.total || importedCount || 0);
  __activeAIJobId = String(startData?.job_id || '');

  if (__activeAIJobId) {
    const pollUrl = `${aiStatusUrl}?job_id=${encodeURIComponent(__activeAIJobId)}`;
    const sseUrl = typeof startData?.sse_url === 'string' ? startData.sse_url : null;
    const totalItems = Number.isFinite(total) && total > 0
      ? total
      : Number.isFinite(importedCount) && importedCount > 0
        ? importedCount
        : undefined;
    wireJobDoneSignals({
      jobId: __activeAIJobId,
      sseUrl,
      pollUrl,
      totalItems
    });
  }

  // Bot√≥n cancelar (aborta XHR si quedara algo y pide cancelaci√≥n del job IA)
  showCancelButton(async () => {
    __cancelRequested = true;
    try { __activeUploadXhr?.abort(); } catch {}
    try {
      if (__activeAIJobId) {
        await fetch(aiCancelUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ job_id: __activeAIJobId }),
          __skipLoadingHook: true,
          __hostEl: getGlobalProgressHost()
        });
      }
    } catch {}
  });

  // 2) Poll + ETA suave
  let processed = 0;
  let finishedOk = false;

  while (true) {
    if (__cancelRequested) {
      tracker.setStage('Cancelando‚Ä¶');
      stopEtaProgress(false);
      break;
    }
    if (etaFinished) {
      finishedOk = true;
      break;
    }
    try {
      const r = await fetch(`${aiStatusUrl}?job_id=${encodeURIComponent(__activeAIJobId)}&t=${Date.now()}`, {
        cache: 'no-store', __skipLoadingHook: true, __hostEl: getGlobalProgressHost()
      });
      if (r.ok) {
        const data = await r.json();
        backendHeartbeat();
        ensureEtaFromSource(data, secondsPerItem);
        processed = Number(data?.processed || processed);
        const tot = Number(data?.total || total || 1);
        const statusNow = String(data?.status || '').toLowerCase();
        const done = statusNow === 'done' || processed >= tot;
        if (statusNow === 'canceling') {
          tracker.setStage('Cancelando‚Ä¶');
        } else if (done) {
          tracker.setStage('IA finalizando‚Ä¶');
        } else {
          tracker.setStage('IA generando‚Ä¶');
        }
        if (statusNow === 'canceled') {
          tracker.setStage('Cancelado');
          stopEtaProgress(false);
          break;
        }
        if (done) {
          await markBackendDone();
          tracker.setStage('Completado');
          finishedOk = true;
          break;
        }
      }
    } catch {
      tracker.setStage('Esperando IA‚Ä¶');
    }

    await sleep(600);
  }

  __activeAIJobId = null;
  hideCancelButton();
  window.__activeAITracker = null;

  // Auto-refresco de la tabla al terminar o cancelar
  try { await reloadTable({ skipProgress: true }); } catch {}

  if (!finishedOk && !__cancelRequested) {
    stopEtaProgress(false);
  }
  __cancelRequested = false;
}

// Ensure the server shuts down cleanly when the tab or window is closed.
// Using fetch with `keepalive` guarantees the request completes even during unload.
window.addEventListener('beforeunload', () => {
  try {
    // Use fetch() instead of sendBeacon() because some browsers
    // drop beacon requests when no payload is provided. The `keepalive`
    // option allows the request to continue in the background while
    // the page is unloading.
    fetch('/shutdown', { method: 'POST', keepalive: true });
  } catch (err) {
    // As a fallback, attempt a minimal beacon with an empty payload.
    try { navigator.sendBeacon('/shutdown', ''); } catch (e) {}
  }
});
// Global arrays to hold all products and the current filtered list
let allProducts = [];
let products = [];
let sortField = null;
let sortDir = 1;
let sortType = 'string';

function ensureAppState(){
  window.appState = window.appState || {};
  return window.appState;
}

function getActiveFilters(){
  const state = ensureAppState();
  if (state.filters) return state.filters;
  const filters = readFilters();
  state.filters = filters;
  return filters;
}
function updateResultsBadge(total) {
  const meta = document.getElementById('listMeta');
  if (!meta) return;
  const count = typeof total === 'number' ? total : (Array.isArray(products) ? products.length : 0);
  meta.textContent = `${count} resultados`;
}

window.updateResultsBadge = updateResultsBadge;
window.allProducts = allProducts;
window.products = products;
const gridRoot = document.getElementById('productTable');

document.addEventListener('filters-changed', (e) => {
  if (e && e.detail) ensureAppState().filters = e.detail;
  selection.clear();
  renderTable();
});

function ecMakeMeasurer() {
  const el = document.createElement('span');
  el.id = 'ec-measure';
  el.style.position = 'absolute';
  el.style.visibility = 'hidden';
  el.style.height = 'auto';
  el.style.width = 'auto';
  el.style.whiteSpace = 'pre';
  el.style.font = 'inherit';
  el.style.letterSpacing = 'inherit';
  document.body.appendChild(el);
  return el;
}
const __ecMeasure = ecMakeMeasurer();

function ecTextPxWidth(text, sampleEl) {
  __ecMeasure.style.font = getComputedStyle(sampleEl).font;
  __ecMeasure.textContent = text || '';
  return __ecMeasure.offsetWidth;
}

const EC_LIMITS = {
  desire:         { min: 120, max: 320, pad: 24 },
  desire_mag:     { min:  90, max: 160, pad: 20 },
  awareness:      { min: 140, max: 220, pad: 20 },
  competition:    { min: 100, max: 160, pad: 20 },
};

function ecClamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function ecAutoFitColumns(gridRoot) {
  const desired = { desire: EC_LIMITS.desire.min, desire_mag: EC_LIMITS.desire_mag.min,
                    awareness: EC_LIMITS.awareness.min, competition: EC_LIMITS.competition.min };

  const rows = gridRoot.querySelectorAll('tr');
  rows.forEach(tr => {
    const tdDesire   = tr.querySelector('td.ec-col-desire input');
    const tdMag      = tr.querySelector('td.ec-col-desire-mag select');
    const tdAware    = tr.querySelector('td.ec-col-awareness select');
    const tdComp     = tr.querySelector('td.ec-col-competition select');

    if (tdDesire) {
      const txt = tdDesire.value || tdDesire.placeholder || '';
      const w = ecTextPxWidth(txt, tdDesire) + EC_LIMITS.desire.pad;
      desired.desire = Math.max(desired.desire, w);
    }
    if (tdMag) {
      const lbl = tdMag.options[tdMag.selectedIndex]?.text || '‚Äî';
      const w = ecTextPxWidth(lbl, tdMag) + EC_LIMITS.desire_mag.pad;
      desired.desire_mag = Math.max(desired.desire_mag, w);
    }
    if (tdAware) {
      const lbl = tdAware.options[tdAware.selectedIndex]?.text || '‚Äî';
      const w = ecTextPxWidth(lbl, tdAware) + EC_LIMITS.awareness.pad;
      desired.awareness = Math.max(desired.awareness, w);
    }
    if (tdComp) {
      const lbl = tdComp.options[tdComp.selectedIndex]?.text || '‚Äî';
      const w = ecTextPxWidth(lbl, tdComp) + EC_LIMITS.competition.pad;
      desired.competition = Math.max(desired.competition, w);
    }
  });

  const d  = ecClamp(desired.desire,       EC_LIMITS.desire.min,      EC_LIMITS.desire.max);
  const dm = ecClamp(desired.desire_mag,   EC_LIMITS.desire_mag.min,  EC_LIMITS.desire_mag.max);
  const aw = ecClamp(desired.awareness,    EC_LIMITS.awareness.min,   EC_LIMITS.awareness.max);
  const co = ecClamp(desired.competition,  EC_LIMITS.competition.min, EC_LIMITS.competition.max);

  gridRoot.style.setProperty('--ec-w-desire',        d  + 'px');
  gridRoot.style.setProperty('--ec-w-desire-mag',    dm + 'px');
  gridRoot.style.setProperty('--ec-w-awareness',     aw + 'px');
  gridRoot.style.setProperty('--ec-w-competition',   co + 'px');

  gridRoot.querySelectorAll('td.ec-col-desire-mag select').forEach(el => el.style.width = (dm - EC_LIMITS.desire_mag.pad) + 'px');
  gridRoot.querySelectorAll('td.ec-col-awareness select').forEach(el => el.style.width = (aw - EC_LIMITS.awareness.pad) + 'px');
  gridRoot.querySelectorAll('td.ec-col-competition select').forEach(el => el.style.width = (co - EC_LIMITS.competition.pad) + 'px');
}
const columns = [
  { key: 'id', label: 'ID', type: 'number' },
  { key: 'image_url', label: 'Imagen', type: 'image' },
  { key: 'name', label: 'Nombre', type: 'string' },
  { key: 'category', label: 'Categor√≠a', type: 'string' },
  { key: 'price', label: 'Price', type: 'number', align: 'center', editable: false,
    headerClass:'price-col', cellClass:'price-col',
    render: row => new Intl.NumberFormat('en-US', { style:'currency', currency:'USD', maximumFractionDigits: 2 }).format(row.price ?? 0) },
  { key: 'Product Rating', label: 'Rating', type: 'number' },
  { key: 'Item Sold', label: 'Unidades Vendidas', type: 'number' },
  { key: 'Revenue($)', label: 'Ingresos', type: 'number' },
  { key: 'Creator Conversion Ratio', label: 'Tasa Conversi√≥n', type: 'string' },
  { key: 'Launch Date', label: 'Fecha Lanzamiento', type: 'string' },
  { key: 'date_range', label: 'Rango Fechas', type: 'string', headerClass: 'cell-date-range', cellClass: 'cell-date-range' },
  { key: 'desire', label: 'Desire', type: 'string', headerClass: 'ec-col ec-col-desire col-desire', cellClass: 'ec-col ec-col-desire col-desire', dataEcCol: 'desire' },
  { key: 'desire_magnitude', label: 'Desire magnetitude', type: 'string', headerClass: 'ec-col ec-col-desire-mag', cellClass: 'ec-col ec-col-desire-mag', dataEcCol: 'desire_magnitude' },
  { key: 'awareness_level', label: 'Awerness Level', type: 'string', headerClass: 'ec-col ec-col-awareness', cellClass: 'ec-col ec-col-awareness', dataEcCol: 'awareness_level' },
  { key: 'competition_level', label: 'Competition level', type: 'string', headerClass: 'ec-col ec-col-competition', cellClass: 'ec-col ec-col-competition', dataEcCol: 'competition_level' },
  { key: 'winner_score', label: 'Winner Score', type: 'number' },
];

let trendingWords = [];

function mapTrendingScore(raw){
  const n = Number(raw);
  if (isNaN(n)) return 0;
  if (n <= 5) return Math.max(0, Math.round(n));
  if (n <= 9) return 0;
  if (n <= 19) return 1;
  if (n <= 34) return 2;
  if (n <= 54) return 3;
  if (n <= 79) return 4;
  return 5;
}

function normalizeDupKey(item){
  const norm = (str) => (str || '')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
    .replace(/\s+/g, ' ');
  return norm(item.name) + '|' + norm(item.image_url);
}

function preprocessProducts(list){
  const dupMap = new Map();
  list.forEach(item => {
    item.trending = mapTrendingScore(item.trendingScore);
    const desireSources = [
      item.desire,
      item.extras && item.extras.desire,
      item.ai_desire,
      item.ai_desire_label,
      item.desire_magnitude
    ];
    let desireVal = '';
    for (const src of desireSources) {
      if (src !== undefined && src !== null && String(src).trim() !== '') {
        desireVal = String(src);
        break;
      }
    }
    item.desire = desireVal;
    if (item.extras && item.extras['duplicate_of']) {
      item.isDuplicate = true;
      return;
    }
    const key = normalizeDupKey(item);
    item._dupKey = key;
    const arr = dupMap.get(key);
    if (arr) arr.push(item); else dupMap.set(key, [item]);
  });
  dupMap.forEach(arr => { if (arr.length > 1) arr.forEach(it => it.isDuplicate = true); });
}

function computeOldnessDays(p){
  const dr = p.date_range || p['Date Range'];
  let start=null;
  if(typeof dr==='string'){
    const m=dr.match(/(\d{4}-\d{2}-\d{2})\s*~\s*(\d{4}-\d{2}-\d{2})/);
    if(m) start=new Date(m[1]);
  }
  if(!start){
    const keys=['first_seen','created_at','createdAt'];
    for(const k of keys){
      const v=p[k];
      if(v){ try{ start=new Date(String(v).slice(0,10)); break; }catch(e){} }
    }
  }
  if(!start) return 0;
  const today=new Date();
  const diff=Math.floor((today-start)/(1000*60*60*24));
  return diff>0?diff:0;
}

async function loadConfig() {
  let cfg = {};
  try {
    cfg = await fetchJson('/config');
  } catch (err) {
    console.error('Error loading config', err);
  }
  if (cfg.model) {
    document.getElementById('modelSelect').value = cfg.model;
  }
  const input = document.getElementById('apiKey');
  const saveBtn = document.getElementById('saveApiKey');
  if (cfg.has_api_key) {
    savedApiKeyHash = cfg.api_key_hash || null;
    savedApiKeyLength = cfg.api_key_length || 0;
    const masked = '‚Ä¢'.repeat(Math.max(savedApiKeyLength - 4, 0)) + (cfg.api_key_last4 || '');
    if (input) input.value = masked;
    if (saveBtn) saveBtn.disabled = true;
    const row = document.querySelector('#config .api-row');
    if (row) row.style.display = 'none';
    document.getElementById('toggleApiKey').style.display = 'inline-flex';
  } else {
    savedApiKeyHash = null;
    savedApiKeyLength = 0;
    if (input) input.value = '';
    if (saveBtn) saveBtn.disabled = true;
  }
}

// helper to highlight trending keywords
function isTrending(name) {
  if (!name) return false;
  const words = name.toLowerCase().split(/[^a-z0-9√°√©√≠√≥√∫√º√±]+/);
  return words.some(w => trendingWords.includes(w));
}

async function fetchProducts(options = {}) {
  const prevSel = new Set(selection);
  const fetchOpts = options && options.skipProgress ? { __skipLoadingHook: true } : undefined;
  const data = await fetchJson('/products', fetchOpts);
  if(data.length && data[0].desire !== undefined && window.ensureColumnVisible){
    ensureColumnVisible('desire');
  }
  allProducts = data;
  preprocessProducts(allProducts);
  allProducts.sort((a,b)=> (Number(a.id)||0) - (Number(b.id)||0));
  sortField = 'id';
  sortDir = 1;
  sortType = 'number';
  window.allProducts = allProducts;
  renderTable();
  const visibleIds = new Set(products.map(p => String(p.id)));
  selection.clear();
  for (const id of prevSel) {
    if (visibleIds.has(id)) selection.add(id);
  }
  updateMasterState();
  renderTable();
}

window.fetchProducts = fetchProducts;
async function reloadTable(options){ await fetchProducts(options); }
async function reloadRows(ids, options){ await fetchProducts(options); }

function renderTable() {
  const headerRow = document.getElementById('headerRow');
  const tbody = document.querySelector('#productTable tbody');
  const baseList = Array.isArray(allProducts) ? allProducts : [];
  const filters = getActiveFilters();
  const filtered = applyFilters(baseList, filters);
  products = Array.isArray(filtered) ? [...filtered] : [];
  sortProducts();
  window.products = products;
  // Build header if empty
  if (!headerRow.hasChildNodes()) {
    // Add select column header (no label)
    const thSel = document.createElement('th');
    const selectAll = document.createElement('input');
    selectAll.type = 'checkbox';
    selectAll.id = 'selectAll';
    thSel.appendChild(selectAll);
    headerRow.appendChild(thSel);
    // Add dynamic columns
    columns.forEach(col => {
      const th = document.createElement('th');
      th.textContent = col.label;
      th.style.cursor = 'pointer';
      th.setAttribute('data-key', col.key);
      if (col.headerClass) th.className = col.headerClass;
      if (col.dataEcCol) th.setAttribute('data-ec-col', col.dataEcCol);
      if (col.width) th.style.width = col.width + 'px';
      if (col.minWidth) th.style.minWidth = col.minWidth + 'px';
      if (col.maxWidth) th.style.maxWidth = col.maxWidth + 'px';
      if (col.align) th.style.textAlign = col.align;
      if (col.key === 'winner_score') th.title = 'Suma ponderada de 10 m√©tricas normalizadas';
      th.onclick = () => sortBy(col.key, col.type);
      headerRow.appendChild(th);
    });
    // Add delete column header
    const thDel = document.createElement('th');
    headerRow.appendChild(thDel);
  }
  // Clear body
  tbody.innerHTML = '';
  const visibleProducts = Array.isArray(products) ? [...products] : [];
  window.__visibleProducts = visibleProducts;
  window.__allProducts = baseList && baseList.length ? baseList : visibleProducts;
  document.dispatchEvent(new CustomEvent('visible-products-changed', {
    detail: { count: visibleProducts.length }
  }));
  // Render rows
  products.forEach(item => {
    const tr = document.createElement('tr');
    if (item.isDuplicate) {
      tr.classList.add('is-duplicate');
    }
    // Selection checkbox
    const tdSel = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.classList.add('rowCheck');
    const rowId = String(item.id);
    cb.dataset.id = rowId;
    cb.checked = selection.has(rowId);
    tr.classList.toggle('selected', cb.checked);
    cb.addEventListener('change', () => {
      const id = cb.dataset.id;
      if (cb.checked) selection.add(id); else selection.delete(id);
      tr.classList.toggle('selected', cb.checked);
      updateMasterState();
    });
    tdSel.appendChild(cb);
    tr.appendChild(tdSel);
    columns.forEach(col => {
      const td = document.createElement('td');
      const key = col.key;
      td.setAttribute('data-key', key);
      if (col.cellClass) td.className = col.cellClass;
      if (col.dataEcCol) td.setAttribute('data-ec-col', col.dataEcCol);
      if (col.width) td.style.width = col.width + 'px';
      if (col.minWidth) td.style.minWidth = col.minWidth + 'px';
      if (col.maxWidth) td.style.maxWidth = col.maxWidth + 'px';
      if (col.align) td.style.textAlign = col.align;
      let value = '';
      if (key === 'desire') {
        // La columna textual "Desire" NUNCA debe tratarse como m√©trica
        value = typeof item.desire === 'string' ? item.desire.trim() : (item.desire ?? '');
      } else if (metricKeys.includes(key)) {
        value = item.winner_score_breakdown && item.winner_score_breakdown.scores ? item.winner_score_breakdown.scores[key] : '';
        if (item.winner_score_breakdown && item.winner_score_breakdown.justifications) {
          const j = item.winner_score_breakdown.justifications[key];
          if (j) td.title = 'Justificaci√≥n: ' + j;
        }
      } else if (key === 'desire_magnitude') {
        value = item.desire_magnitude;
      } else if (['id','name','category','price','image_url','winner_score','awareness_level','competition_level','date_range'].includes(key)) {
        value = item[key];
      } else {
        value = item.extras ? item.extras[key] : '';
      }
      if (col.render) {
        try { td.textContent = col.render(item); } catch (e) { td.textContent = ''; }
      } else if (key === 'winner_score') {
        const sc = parseFloat(value);
        if (!isNaN(sc)) {
          const scInt = Math.round(sc);
          td.innerHTML = '<span class="' + winnerScoreClass(scInt) + '">' + scInt.toLocaleString(undefined,{maximumFractionDigits:0}) + '</span>';
          if (item.winner_score_breakdown && item.winner_score_breakdown.justifications) {
            const j = item.winner_score_breakdown.justifications;
            const tooltip = Object.entries(j).map(([k,v])=>`${k}: ${v}`).join('\n');
            td.title = tooltip;
          }
        }
      } else if (key === 'image_url' && value) {
        const img = document.createElement('img');
        img.src = value;
        // Increase the preview size for better visibility
        img.style.width = '100px';
        img.style.height = '100px';
        img.style.objectFit = 'cover';
        // Show larger image on click
        img.style.cursor = 'pointer';
        img.onclick = () => {
          showOverlay(value);
        };
        td.appendChild(img);
      } else if (key === 'name') {
        const safeName = value == null ? '' : String(value);
        if (safeName) {
          const nameSpan = document.createElement('span');
          nameSpan.textContent = safeName;
          td.appendChild(nameSpan);
        }
        // If Kalodata URL exists, add copy link button
        const kal = item.extras && item.extras['KalodataUrl'];
        if (kal) {
          const btnCopy = document.createElement('button');
          btnCopy.textContent = 'üìã';
          btnCopy.title = 'Copiar link Kalodata';
          btnCopy.style.marginLeft = '5px';
          btnCopy.style.padding = '2px 6px';
          btnCopy.style.fontSize = '12px';
          btnCopy.onclick = () => {
            navigator.clipboard.writeText(kal).then(() => {
              toast.success('Link copiado al portapapeles');
            });
          };
          td.appendChild(btnCopy);
        }
      } else if (key === 'desire') {
        let current = value || '';
        const render = () => {
          td.innerHTML = '';
          td.title = current;
          const wrap = document.createElement('div');
          wrap.className = 'desire-text';
          wrap.textContent = current;
          td.appendChild(wrap);
          wrap.addEventListener('click', () => {
            if (td.querySelector('textarea')) return;
            const ta = document.createElement('textarea');
            ta.className = 'desire-editor';
            ta.rows = 4;
            ta.value = current;
            td.innerHTML = '';
            td.appendChild(ta);
            ta.focus();
            ta.addEventListener('blur', async () => {
              const val = ta.value.trim() || null;
              try {
                await fetch(`/api/products/${item.id}`, {
                  method: 'PATCH',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ desire: val })
                });
              } catch (e) {}
              item.desire = val;
              current = val || '';
              render();
              ecAutoFitColumns(gridRoot);
            });
          });
        };
        render();
      } else if (key === 'desire_magnitude') {
        const select = document.createElement('select');
        ['', 'Low', 'Medium', 'High'].forEach(opt => {
          const o = document.createElement('option');
          o.value = opt;
          o.textContent = opt || '‚Äî';
          if (value === opt) o.selected = true;
          select.appendChild(o);
        });
        select.addEventListener('change', async () => {
          const val = select.value || null;
          try { await api.updateProductField(item.id, { desire_magnitude: val }); } catch(e) {}
          item.desire_magnitude = val;
        });
        td.appendChild(select);
      } else if (key === 'awareness_level') {
        const select = document.createElement('select');
        ['', 'Unaware', 'Problem-Aware', 'Solution-Aware', 'Product-Aware', 'Most Aware'].forEach(opt => {
          const o = document.createElement('option');
          o.value = opt;
          o.textContent = opt || '‚Äî';
          if (value === opt) o.selected = true;
          select.appendChild(o);
        });
        select.addEventListener('change', async () => {
          const val = select.value || null;
          try { await api.updateProductField(item.id, { awareness_level: val }); } catch(e) {}
          item.awareness_level = val;
        });
        td.appendChild(select);
      } else if (key === 'competition_level') {
        const select = document.createElement('select');
        ['', 'Low', 'Medium', 'High'].forEach(opt => {
          const o = document.createElement('option');
          o.value = opt;
          o.textContent = opt || '‚Äî';
          if (value === opt) o.selected = true;
          select.appendChild(o);
        });
        select.addEventListener('change', async () => {
          const val = select.value || null;
          try { await api.updateProductField(item.id, { competition_level: val }); } catch(e) {}
          item.competition_level = val;
        });
        td.appendChild(select);
      } else if (col.type === 'number' && value !== null && value !== undefined && value !== '') {
        let num = parseFloat(String(value).replace(/[^0-9.-]+/g, ''));
        if (isNaN(num)) {
          td.textContent = '';
        } else {
          if (key === 'Item Sold' || key === 'Revenue($)' || key === 'Creator Number') {
            td.textContent = abbr(num);
          } else {
            td.textContent = num.toLocaleString();
          }
        }
      } else {
        td.textContent = value || '';
      }
      tr.appendChild(td);
    });
    // Delete button
    const tdDel = document.createElement('td');
    const btn = document.createElement('button');
    btn.textContent = '‚úñ';
    btn.title = 'Eliminar producto';
    btn.style.background = 'transparent';
    btn.style.border = 'none';
    btn.style.cursor = 'pointer';
    btn.style.color = 'red';
    btn.dataset.id = item.id;
    btn.onclick = () => {
      toast.info('¬øEliminar producto?', {actionText:'Eliminar', onAction: () => deleteProduct(item.id)});
    };
    tdDel.appendChild(btn);
    tr.appendChild(tdDel);
    tbody.appendChild(tr);
  });
  currentPageIds = products.map(p => String(p.id));
  updateResultsBadge(currentPageIds.length);
  if (window.refreshColumns) window.refreshColumns();
  if (window.applyColumnVisibility) window.applyColumnVisibility();
  updateMasterState();
  ecAutoFitColumns(gridRoot);
}

gridRoot.addEventListener('input',  e => { if (e.target.closest('td.ec-col-desire')) ecAutoFitColumns(gridRoot); });
gridRoot.addEventListener('change', e => { if (e.target.closest('td.ec-col-desire-mag, td.ec-col-awareness, td.ec-col-competition')) ecAutoFitColumns(gridRoot); });
window.addEventListener('resize', (() => { let t; return () => { clearTimeout(t); t = setTimeout(() => ecAutoFitColumns(gridRoot), 150); }; })());

function sortProducts(){
  if(!sortField) return;
  const field = sortField;
  const type = sortType;
  products.sort((a,b)=>{
    let va; let vb;
    if (field === 'id' || field === 'name' || field === 'category' || field === 'price' || field === 'image_url' || field === 'winner_score' || field === 'desire' || field === 'desire_magnitude' || field === 'awareness_level' || field === 'competition_level') {
      va = a[field];
      vb = b[field];
    } else if (metricKeys.includes(field)) {
      va = a.winner_score_breakdown && a.winner_score_breakdown.scores ? a.winner_score_breakdown.scores[field] : undefined;
      vb = b.winner_score_breakdown && b.winner_score_breakdown.scores ? b.winner_score_breakdown.scores[field] : undefined;
    } else {
      va = a.extras ? a.extras[field] : undefined;
      vb = b.extras ? b.extras[field] : undefined;
    }
    if (type === 'number') {
      const na = parseFloat(String(va).replace(/[^0-9.-]+/g, ''));
      const nb = parseFloat(String(vb).replace(/[^0-9.-]+/g, ''));
      if (isNaN(na) && isNaN(nb)) return 0;
      if (isNaN(na)) return sortDir * 1;
      if (isNaN(nb)) return sortDir * -1;
      return (na - nb) * sortDir;
    }
    const sa = (va || '').toString().toLowerCase();
    const sb = (vb || '').toString().toLowerCase();
    if (sa < sb) return -1 * sortDir;
    if (sa > sb) return 1 * sortDir;
    return 0;
  });
}

function sortBy(field, type) {
  if (sortField === field) {
    sortDir = -sortDir;
  } else {
    sortField = field;
    sortDir = 1;
    sortType = type;
  }
  sortProducts();
  renderTable();
}

document.getElementById('refreshBtn').onclick = fetchProducts;
window.onload = async () => {
  await ensureApiKey();
  await loadConfig();
  await fetchProducts();
  const tid = localStorage.getItem(IMPORT_TASK_LS_KEY);
  if (tid) {
    toast.info('Reanudando importaci√≥n previa‚Ä¶');
    const host = getGlobalProgressHost();
    const tracker = LoadingHelpers.start('Importando cat√°logo', { host });
    setEtaTracker(tracker);
    setProgressUI(0);
    tracker.setStage('Reanudando‚Ä¶');
    try {
      const result = await followImportTask(tid, tracker, {
        host,
        secondsPerItem: ETA_SECONDS_PER_ITEM,
      });
      const importedCount = result?.imported ?? result?.rows_imported;
      if (Number.isFinite(importedCount) && importedCount > 0) {
        toast.success(`Importados ${importedCount}`);
      }
      tracker.setStage('Completado');
    } catch (err) {
      tracker.setStage('Error');
      stopEtaProgress(false);
      toast.error(err?.message || 'Error en importaci√≥n');
    } finally {
      localStorage.removeItem(IMPORT_TASK_LS_KEY);
      tracker.done();
      hideImportBanner();
      setEtaTracker(null);
    }
  }
};
// Toggle config panel
document.getElementById('configBtn').onclick = async () => {
  await openConfigModal();
  const cfg = document.getElementById('config');
  const wcard = document.getElementById('weightsCard');
  const footer = document.getElementById('weightsFooter');
  if(!cfg || !wcard || !footer || !window.modalManager) return;
  const btn = document.getElementById('configBtn');
  const modal = document.createElement('div');
  modal.id = 'configModal';
  modal.className = 'modal config-modal';
  modal.setAttribute('role','dialog');
  modal.setAttribute('aria-modal','true');
  modal.setAttribute('aria-labelledby','configModalTitle');
  modal.innerHTML = `
    <header class="modal-header">
      <h3 id="configModalTitle">Configuraci√≥n</h3>
      <div class="modal-progress-slot progress-slot" aria-live="polite"></div>
      <button type="button" class="modal-close" aria-label="Cerrar">‚úï</button>
    </header>
    <div class="modal-body"></div>
  `;
  const body = modal.querySelector('.modal-body');
  const cfgParent = cfg.parentElement;
  const wParent = wcard.parentElement;
  const fParent = footer.parentElement;
  const cfgNext = cfg.nextSibling;
  const wNext = wcard.nextSibling;
  const fNext = footer.nextSibling;
  body.appendChild(cfg);
  body.appendChild(wcard);
  modal.appendChild(footer);
  cfg.style.display = 'block';
  wcard.style.display = 'block';
  footer.style.display = 'flex';
  const handle = modalManager.open(modal, {returnFocus: btn, closeOnBackdrop:true, onClose: () => {
    cfg.style.display = 'none';
    wcard.style.display = 'none';
    footer.style.display = 'none';
    cfgParent.insertBefore(cfg, cfgNext);
    wParent.insertBefore(wcard, wNext);
    fParent.insertBefore(footer, fNext);
    saveIfDirty();
  }});
  modal.querySelector('.modal-close').addEventListener('click', () => handle.close());
  modal.addEventListener('close', saveIfDirty);
  const first = modal.querySelector('input,select,textarea,button');
  if(first) first.focus();
};


// Handle file upload: clicking the upload button opens file chooser
const fileInputEl = document.getElementById('fileInput');
document.getElementById('uploadBtn').onclick = () => {
  fileInputEl.click();
};
// When a file is selected, automatically upload it
fileInputEl.onchange = async (ev) => {
  ev.preventDefault();
  const file = fileInputEl.files[0];
  if (!file) return;
  __cancelRequested = false;
  try {
    await importCatalog(file, {
      startUrl: IMPORT_START_URL,
      statusUrl: IMPORT_STATUS_URL,
      withAI: true,
      aiStartUrl: AI_START_URL,
      aiStatusUrl: AI_STATUS_URL,
      aiCancelUrl: AI_CANCEL_URL
    });
  } catch (err) {
    if (err?.name !== 'AbortError') {
      console.error(err);
    }
  } finally {
    fileInputEl.value = '';
  }
};
// search feature
document.getElementById('searchBtn').onclick = () => {
  const term = document.getElementById('searchInput').value.trim().toLowerCase();
  const tbody = document.querySelector('#productTable tbody');
  let visible = 0;
  Array.from(tbody.rows).forEach(row => {
    if (!term) {
      row.style.display = '';
      visible++;
      return;
    }
    const cells = Array.from(row.cells).map(td => td.textContent.toLowerCase());
    const match = cells.some(text => text.includes(term));
    row.style.display = match ? '' : 'none';
    if (match) visible++;
  });
  updateResultsBadge(visible);
};
const gptField = document.getElementById('gptPrompt');
const sendPromptBtn = document.getElementById('sendPrompt');

function autoGrow(el){
  el.style.height = 'auto';
  el.style.height = el.scrollHeight + 'px';
}

if(gptField){
  const saved = localStorage.getItem('lastGptPrompt');
  if(saved){
    gptField.value = saved;
    autoGrow(gptField);
  }
  gptField.addEventListener('input', () => {
    autoGrow(gptField);
    localStorage.setItem('lastGptPrompt', gptField.value);
  });
  gptField.addEventListener('keydown', e => {
    if(e.key === 'Enter' && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      sendPromptHandler();
    }
  });
}

async function sendPromptHandler(){
  const prompt = gptField.value.trim();
  if(!prompt){ toast.info('Escribe una consulta'); return; }
  sendPromptBtn.disabled = true;
  try {
    const data = await fetchJson('/custom_gpt', {method:'POST', body: JSON.stringify({prompt})});
    const history = document.getElementById('history');
    if(history){
      const details = document.createElement('details');
      const summary = document.createElement('summary');
      const shortPrompt = prompt.length > 40 ? prompt.substring(0,37) + '...' : prompt;
      summary.textContent = shortPrompt;
      const pre = document.createElement('pre');
      pre.textContent = data.response || data.error;
      details.appendChild(summary);
      details.appendChild(pre);
      history.prepend(details);
    }
    toast.success('Consulta enviada');
    gptField.value = '';
    localStorage.removeItem('lastGptPrompt');
    autoGrow(gptField);
  } catch(err) {
    toast.error(err.message || 'Error al enviar');
  } finally {
    sendPromptBtn.disabled = false;
  }
}

sendPromptBtn.onclick = sendPromptHandler;
document.getElementById('darkToggle').onclick = () => {
  document.body.classList.toggle('dark');
};

// Helper to parse dates from various formats (YYYY-MM-DD or other)
function parseDate(value) {
  if (!value) return null;
  // Try direct Date parse
  const d = new Date(value);
  if (!isNaN(d)) return d;
  // Try splitting by non-digit
  const parts = String(value).match(/(\d{4})[\/-]?(\d{2})[\/-]?(\d{2})/);
  if (parts) {
    const y = parseInt(parts[1]);
    const m = parseInt(parts[2]) - 1;
    const day = parseInt(parts[3]);
    return new Date(y, m, day);
  }
  return null;
}


async function postApiKey(value){
  const resp = await fetch('/api/auth/set-key', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({api_key:value})
  });
  let data = {};
  try{ data = await resp.json(); } catch{}
  if(resp.ok && data.ok){
    savedApiKeyHash = await sha256(value);
    savedApiKeyLength = value.length;
    return {ok:true};
  }
  return {ok:false, error:data.error||'Error'};
}

async function showApiKeyModal(){
  return new Promise(res=>{
    const modal=document.createElement('div');
    modal.className='modal';
    modal.setAttribute('role','dialog');
    modal.setAttribute('aria-modal','true');
    modal.innerHTML='<header class="modal-header"><h3>API Key requerida</h3></header><div class="modal-body"><input type="password" id="modalApiKey" placeholder="API Key"><div class="api-error" style="color:red"></div><button id="modalSaveApiKey">Guardar y Verificar</button></div>';
    const handle=modalManager.open(modal,{closeOnBackdrop:false});
    const input=modal.querySelector('#modalApiKey');
    const errEl=modal.querySelector('.api-error');
    modal.querySelector('#modalSaveApiKey').onclick=async()=>{
      const val=input.value.trim();
      if(!val){ toast.error('La API Key no puede estar vac√≠a'); return; }
      const r=await postApiKey(val);
      if(r.ok){ handle.close(); res(true); }
      else{ errEl.textContent=r.error||'Error'; }
    };
    input.focus();
  });
}

async function ensureApiKey(){
  try{
    let resp=await fetch('/api/auth/has-key');
    let data=await resp.json();
    while(!data.has_key){
      await showApiKeyModal();
      resp=await fetch('/api/auth/has-key');
      data=await resp.json();
    }
  }catch(err){ console.error('Error checking API key',err); }
}

document.getElementById('toggleApiKey').onclick = () => {
  showApiKeyModal();
};

const apiKeyInput = document.getElementById('apiKey');
const saveApiKeyBtn = document.getElementById('saveApiKey');

apiKeyInput.addEventListener('input', async () => {
  const val = apiKeyInput.value.trim();
  let same = false;
  if (savedApiKeyHash && val) {
    const hash = await sha256(val);
    same = hash === savedApiKeyHash;
  }
  saveApiKeyBtn.disabled = !val || same;
});

saveApiKeyBtn.addEventListener('click', async () => {
  const value = apiKeyInput.value.trim();
  if (!value) { toast.error('La API Key no puede estar vac√≠a'); return; }
  const r = await postApiKey(value);
  if(!r.ok){ toast.error('No se pudo guardar la API Key'); return; }
  toast.success('API Key guardada');
  const masked = '‚Ä¢'.repeat(Math.max(savedApiKeyLength - 4, 0)) + value.slice(-4);
  apiKeyInput.value = masked;
  saveApiKeyBtn.disabled = true;
});

// Show overlay with larger image
function showOverlay(src){
  const overlay = document.getElementById('imgOverlay');
  const img = document.getElementById('overlayImg');
  img.src = src;
  overlay.style.display = 'flex';
}
// Hide overlay only when clicking outside the image
document.getElementById('imgOverlay').onclick = (e) => {
  if (e.target.id === 'imgOverlay') {
    document.getElementById('imgOverlay').style.display = 'none';
  }
};

  // Delete a single product by ID
  async function deleteProduct(id){
    const host = getActionHost();
    const tracker = LoadingHelpers.start('Eliminando productos', { host });
    try {
      if (typeof currentGroupFilter !== 'undefined' && currentGroupFilter > 0) {
        const data = await fetchJson('/remove_from_list', {
          method:'POST',
          body: JSON.stringify({list_id: currentGroupFilter, ids: [id]}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar del grupo: '+data.error); }
        await applyGroupFilter(currentGroupFilter, { skipProgress: true, host });
      } else {
        const data = await fetchJson('/delete', {
          method:'POST',
          body: JSON.stringify({ids: [id]}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar: '+data.error); }
        await fetchProducts();
      }
    } catch(err){
      console.error(err);
      toast.error('Error al eliminar');
    } finally {
      tracker.done();
    }
  }

// Delete selected products
document.getElementById('btnDelete').onclick = () => {
  const ids = Array.from(selection, Number);
  if(!ids.length){ toast.info('Selecciona al menos un producto para eliminar'); return; }
  toast.info('¬øEliminar los productos seleccionados?', {actionText:'Eliminar', onAction: async () => {
    const host = getActionHost();
    const tracker = LoadingHelpers.start('Eliminando productos', { host });
    try{
      if (typeof currentGroupFilter !== 'undefined' && currentGroupFilter > 0) {
        const data = await fetchJson('/remove_from_list', {
          method:'POST',
          body: JSON.stringify({list_id: currentGroupFilter, ids: ids}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar del grupo: '+data.error); } else { toast.success('Eliminados del grupo: '+data.removed); }
        await applyGroupFilter(currentGroupFilter, { skipProgress: true, host });
      } else {
        const data = await fetchJson('/delete', {
          method:'POST',
          body: JSON.stringify({ids: ids}),
          __hostEl: host,
          __skipLoadingHook: true
        });
        if(data.error){ toast.error('Error al eliminar: '+data.error); } else { toast.success('Productos eliminados: '+data.deleted); }
        await fetchProducts();
      }
    }catch(err){
      console.error(err);
      toast.error('Error al eliminar');
    } finally {
      tracker.done();
    }
  }});
};

// Export selected products as formatted XLSX
document.getElementById('btnExport').onclick = async () => {
  const ids = getSelectedProductIds();
  if(!ids.length){ toast.info('Selecciona productos para exportar'); return; }
  const btn = document.getElementById('btnExport');
  const host = getActionHost();
  const tracker = LoadingHelpers.start('Preparando exportaci√≥n', { host });
  btn.disabled = true;
  try{
    tracker.setStage('Generando XLSX‚Ä¶');
    const res = await fetch('/api/export/kalodata-minimal', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ ids }),
      __hostEl: host,
      __skipLoadingHook: true,
    });
    if(!res.ok){
      let message = 'Error al exportar';
      try{
        const payload = await res.json();
        if(payload && payload.error){ message = payload.error; }
      }catch(_err){/* ignore */}
      toast.error(message);
      tracker.step(1, 'Error');
      return;
    }
    tracker.setStage('Descargando‚Ä¶');
    const blob = await res.blob();
    const disposition = res.headers.get('Content-Disposition');
    let filename = 'kalodata_for_analysis.xlsx';
    if(disposition){
      const match = disposition.match(/filename="?([^\"]+)"?/);
      if(match){ filename = match[1]; }
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    toast.success('Archivo exportado');
    tracker.step(1, 'Completado');
  } catch(err){
    console.error(err);
    toast.error('Error al exportar');
    tracker.step(1, 'Error');
  } finally {
    btn.disabled = getSelectedProductIds().length===0;
    tracker.done();
  }
};

const btnExportKalodataMinimal = document.getElementById('btn-export-kalodata-minimal');
if(btnExportKalodataMinimal){
  btnExportKalodataMinimal.onclick = async () => {
    const ids = getSelectedProductIds();
    if(!ids.length){ toast.info('Selecciona productos para exportar'); return; }
    btnExportKalodataMinimal.disabled = true;
    try{
      const res = await fetch('/api/export/kalodata-minimal', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ ids }),
        __skipLoadingHook: true,
      });
      if(!res.ok){
        let message = 'Error al preparar archivo';
        try{
          const payload = await res.json();
          if(payload && payload.error){ message = payload.error; }
        }catch(_err){/* ignore */}
        toast.error(message);
        return;
      }
      const blob = await res.blob();
      const disposition = res.headers.get('Content-Disposition');
      let filename = 'kalodata_for_analysis.xlsx';
      if(disposition){
        const match = disposition.match(/filename="?([^\"]+)"?/);
        if(match){ filename = match[1]; }
      }
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      toast.success('Archivo listo');
    }catch(err){
      console.error(err);
      toast.error('Error al preparar archivo');
    }finally{
      const hasSelection = getSelectedProductIds().length>0;
      btnExportKalodataMinimal.disabled = !hasSelection;
    }
  };
}

function getSelectedProductIds(){ return Array.from(selection, Number); }

// Generate Winner Score for selected or all products
document.getElementById('btnGenWinner').onclick = async () => {
  const host = getGlobalProgressHost();
  const tracker = LoadingHelpers.start('Generando Winner Score', { host });
  try {
    const ids = getSelectedProductIds();
    const rows = ids.length ? allProducts.filter(p=>ids.includes(Number(p.id))) : products;
    const payloadProducts = rows.map(p=>{
      const metrics={};
      metricKeys.forEach(k=>{ if(p[k]!==undefined) metrics[k]=p[k]; });
      return {id:p.id, metrics};
    });
    if(payloadProducts.some(p=>Object.keys(p.metrics).length<metricKeys.length)){
      toast.info('Algunos productos tienen m√©tricas faltantes');
    }
    tracker.step(0.15);
    const body = ids.length ? {product_ids: ids} : {};
    body.products = payloadProducts;
    tracker.step(0.35);
    const res = await fetch('/api/winner-score/generate?debug=1', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body),
      __hostEl: host,
      __skipLoadingHook: true
    });
    let payload = {};
    try { payload = await res.json(); }
    catch (_) { payload = {}; }
    if (!res.ok) {
      throw new Error(payload?.error || res.statusText || 'Error al recalcular');
    }
    const { processed = 0, updated = 0, diag } = payload;
    if(!processed) {
      toast.info('Nada que recalcular (0 seleccionados)');
    } else if(updated>0) {
      toast.success(`Winner Score recalculado: ${updated}/${processed} cambiaron`);
    } else {
      if(diag && diag.sum_filtered===0){
        toast.info(`Recalculado ${processed}. No afect√≥: los pesos de m√©tricas presentes suman 0 ‚Üí fallback uniforme.`);
      } else {
        toast.info(`Recalculado ${processed}. El entero 0‚Äì100 no vari√≥ (redondeo).`);
      }
    }
    tracker.step(0.7);
    if(ids.length) await reloadRows(ids, { skipProgress: true });
    else await reloadTable({ skipProgress: true });
    tracker.step(1);
  } catch(err){
    console.error(err);
    toast.error('No se pudo actualizar el Winner Score');
    tracker.step(1);
  } finally {
    tracker.done();
  }
};

// -------- Group management --------
let currentGroupFilter = -1; // -1 indicates all products

async function loadLists() {
  try {
    const select = document.getElementById('groupSelect');
    if (!select) return;
    const lists = await groupsService.listGroups();
    select.innerHTML = '';

    const allOpt = document.createElement('option');
    allOpt.value = -1;
    allOpt.textContent = 'Todos';
    select.appendChild(allOpt);

    (lists || []).forEach(lst => {
      const opt = document.createElement('option');
      opt.value = lst.id;
      opt.textContent = lst.name;
      select.appendChild(opt);
    });

    select.value = currentGroupFilter.toString();
    select.onchange = (e) => {
      const id = parseInt(e.target.value);
      applyGroupFilter(id);
    };
  } catch(err) {
    console.error(err);
  }
}

window.loadLists = loadLists;
document.addEventListener('groups-updated', () => loadLists());

async function applyGroupFilter(id, { skipProgress = false, host = null } = {}){
  if(id === -1){
    // load all products
    currentGroupFilter = -1;
    fetchProducts();
    // refresh lists to update active styling
    loadLists();
    return;
  }
  try{
    currentGroupFilter = id;
    const fetchOpts = skipProgress ? { __skipLoadingHook: true, __hostEl: host } : (host ? { __hostEl: host } : undefined);
    const data = await fetchJson('/list/' + id, fetchOpts);
    allProducts = data;
    window.allProducts = allProducts;
    selection.clear();
    renderTable();
    // refresh lists to highlight active group
    loadLists();
  } catch(err){ console.error(err); toast.error('Error al cargar lista'); }
}

// create list button
document.getElementById('createListBtn').onclick = async () => {
  const name = document.getElementById('newListName').value.trim();
  if(!name){ toast.info('Ingresa un nombre para el grupo'); return; }
  try{
    await groupsService.createGroup(name);
    document.getElementById('newListName').value = '';
    loadLists();
  }catch(err){ console.error(err); toast.error('Error al crear grupo'); }
};

// load lists on page load
window.addEventListener('DOMContentLoaded', () => {
  loadLists();
});
window.renderTable = renderTable;
window.parseDate = parseDate;
</script>
<script type="module" src="/static/js/completar-ia.js" defer></script>
<script type="module" src="/static/js/filters-panel.js" defer></script>
</body>
</html>
